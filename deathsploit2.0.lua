--Welcome to Deathsploit 2.0! This is the longer version of deathsploit.

-- Thanks for your purchase of $5!
wait(3)
print ("Deathsploit 2.0 GUI Has been injected.")
print ("Thanks for your purchase of $5 USD")
print ("Please check out our website at https://deathsploit.xyz as it will contain news, (sorry for bad design atm)")
print ("Deathsploit is powered by Synapse X Buy synapse x at x.synapse.to! If you're interested in our older products deathsploit 1.0 is included in this script hub.")

--start sequence--

local ScreenGui = Instance.new("ScreenGui")
local Main = Instance.new("ImageLabel")
local UIGradient = Instance.new("UIGradient")
local UICorner = Instance.new("UICorner")
local power = Instance.new("ImageButton")
local TextLabel = Instance.new("TextLabel")
local attach_money = Instance.new("ImageButton")
local TextLabel_2 = Instance.new("TextLabel")
local Execute1 = Instance.new("TextButton")
local UICorner_2 = Instance.new("UICorner")
local Execute2 = Instance.new("TextButton")
local UICorner_3 = Instance.new("UICorner")
local Execute3 = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local Execute4 = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local Execute5 = Instance.new("TextButton")
local UICorner_6 = Instance.new("UICorner")
local Execute6 = Instance.new("TextButton")
local UICorner_7 = Instance.new("UICorner")
local Execute7 = Instance.new("TextButton")
local UICorner_8 = Instance.new("UICorner")
local Execute8 = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local Execute9 = Instance.new("TextButton")
local UICorner_10 = Instance.new("UICorner")
local Execute10 = Instance.new("TextButton")
local UICorner_11 = Instance.new("UICorner")
local Execute11 = Instance.new("TextButton")
local UICorner_12 = Instance.new("UICorner")
local Execute12 = Instance.new("TextButton")
local UICorner_13 = Instance.new("UICorner")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

Main.Name = "Main"
Main.Parent = ScreenGui
Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Main.BackgroundTransparency = 1.000
Main.Position = UDim2.new(0.0420348048, 0, 0.296185941, 0)
Main.Size = UDim2.new(0, 687, 0, 318)
Main.Image = "rbxassetid://3570695787"
Main.ScaleType = Enum.ScaleType.Slice
Main.SliceCenter = Rect.new(100, 100, 100, 100)
Main.SliceScale = 0.120
Main.Active = true
Main.Draggable = true

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(37, 163, 130)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(240, 208, 65))}
UIGradient.Parent = Main

UICorner.CornerRadius = UDim.new(0, 4)
UICorner.Parent = Main

power.Name = "power"
power.Parent = Main
power.BackgroundTransparency = 1.000
power.Position = UDim2.new(0.0188679248, 0, 0.0213414636, 0)
power.Size = UDim2.new(0, 25, 0, 27)
power.ZIndex = 2
power.Image = "rbxassetid://6764432408"
power.ImageRectOffset = Vector2.new(100, 400)
power.ImageRectSize = Vector2.new(50, 50)

TextLabel.Parent = Main
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(0.071278818, 0, 0.0457317159, 0)
TextLabel.Size = UDim2.new(0, 473, 0, 12)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Deathsploit 2.0 FE Script Hub - deathsploit.xyz"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextSize = 32.000

attach_money.Name = "attach_money"
attach_money.Parent = Main
attach_money.BackgroundTransparency = 1.000
attach_money.Position = UDim2.new(0.0325472429, 0, 0.880003095, 0)
attach_money.Size = UDim2.new(0, 25, 0, 25)
attach_money.ZIndex = 2
attach_money.Image = "rbxassetid://3926307971"
attach_money.ImageRectOffset = Vector2.new(964, 484)
attach_money.ImageRectSize = Vector2.new(36, 36)

TextLabel_2.Parent = Main
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.Position = UDim2.new(0.0706551448, 0, 0.876797974, 0)
TextLabel_2.Size = UDim2.new(0, 316, 0, 27)
TextLabel_2.Font = Enum.Font.SourceSans
TextLabel_2.Text = "if you like Deathsploit 2.0 please let us know!"
TextLabel_2.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_2.TextSize = 20.000

Execute1.Name = "Execute1"
Execute1.Parent = Main
Execute1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute1.BorderSizePixel = 0
Execute1.Position = UDim2.new(0.0335429758, 0, 0.14939025, 0)
Execute1.Size = UDim2.new(0, 169, 0, 50)
Execute1.Font = Enum.Font.SourceSans
Execute1.Text = "Auto Rob - Jailbreak"
Execute1.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute1.TextSize = 21.000
Execute1.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/wawsdasdacx/ohascriptnrrewading/main/jbsaxcriptidk1"))();
end)

UICorner_2.Parent = Execute1

Execute2.Name = "Execute2"
Execute2.Parent = Main
Execute2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute2.BorderSizePixel = 0
Execute2.Position = UDim2.new(0.291380554, 0, 0.14939025, 0)
Execute2.Size = UDim2.new(0, 169, 0, 50)
Execute2.Font = Enum.Font.SourceSans
Execute2.Text = "Deathsploit Admin FE"
Execute2.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute2.TextSize = 21.000
Execute2.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://deathsploit.xyz/deathsploitadmin.lua"))();
end)

UICorner_3.Parent = Execute2

Execute3.Name = "Execute3"
Execute3.Parent = Main
Execute3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute3.BorderSizePixel = 0
Execute3.Position = UDim2.new(0.0334167145, 0, 0.326124996, 0)
Execute3.Size = UDim2.new(0, 169, 0, 50)
Execute3.Font = Enum.Font.SourceSans
Execute3.Text = "Mad City AutoFarm"
Execute3.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute3.TextSize = 21.000
Execute3.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/samandroidpro/Chicken/main/MadChickenGui"))()
end)

UICorner_4.Parent = Execute3

Execute4.Name = "Execute4"
Execute4.Parent = Main
Execute4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute4.BorderSizePixel = 0
Execute4.Position = UDim2.new(0.291358918, 0, 0.326124996, 0)
Execute4.Size = UDim2.new(0, 169, 0, 50)
Execute4.Font = Enum.Font.SourceSans
Execute4.Text = "Dark Hub (universal)"
Execute4.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute4.TextSize = 21.000
Execute4.MouseButton1Down:connect(function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/RandomAdamYT/DarkHub/master/Init'))()
end)

UICorner_5.Parent = Execute4

Execute5.Name = "Execute5"
Execute5.Parent = Main
Execute5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute5.BorderSizePixel = 0
Execute5.Position = UDim2.new(0.0334167182, 0, 0.508817315, 0)
Execute5.Size = UDim2.new(0, 169, 0, 50)
Execute5.Font = Enum.Font.SourceSans
Execute5.Text = "Vehicle Sim Autofarm"
Execute5.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute5.TextSize = 21.000
Execute5.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("loadstring(game:HttpGet('https://system-exodus.com/scripts/misc-releases/VehicleSimulator.lua"))()
end)

UICorner_6.Parent = Execute5

Execute6.Name = "Execute6"
Execute6.Parent = Main
Execute6.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute6.BorderSizePixel = 0
Execute6.Position = UDim2.new(0.291358918, 0, 0.508817315, 0)
Execute6.Size = UDim2.new(0, 169, 0, 50)
Execute6.Font = Enum.Font.SourceSans
Execute6.Text = "Prison Life GUI"
Execute6.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute6.TextSize = 21.000
Execute6.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/Neon-Fox/roblox-scripts/main/PLG-v3.1",true))()
end)

UICorner_7.Parent = Execute6

Execute7.Name = "Execute7"
Execute7.Parent = Main
Execute7.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute7.BorderSizePixel = 0
Execute7.Position = UDim2.new(0.0334167182, 0, 0.688304484, 0)
Execute7.Size = UDim2.new(0, 169, 0, 50)
Execute7.Font = Enum.Font.SourceSans
Execute7.Text = "Trade Tower - Script"
Execute7.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute7.TextSize = 21.000
Execute7.MouseButton1Down:connect(function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/laderite/scripts/main/trade%20tower'))()
end)

UICorner_8.Parent = Execute7

Execute8.Name = "Execute8"
Execute8.Parent = Main
Execute8.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute8.BorderSizePixel = 0
Execute8.Position = UDim2.new(0.291358918, 0, 0.688304484, 0)
Execute8.Size = UDim2.new(0, 169, 0, 50)
Execute8.Font = Enum.Font.SourceSans
Execute8.Text = "Interaxis Hub"
Execute8.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute8.TextSize = 21.000
Execute8.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://gist.githubusercontent.com/SynapseXuser/6a84f26ba169311dfe89bd3c83238d31/raw/eb54022d4f801c0776b7679ff5dc3c7d10fd1bd5/interaxis%2520hub"))()
end)

UICorner_9.Parent = Execute8

Execute9.Name = "Execute9"
Execute9.Parent = Main
Execute9.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute9.BorderSizePixel = 0
Execute9.Position = UDim2.new(0.550353348, 0, 0.688304424, 0)
Execute9.Size = UDim2.new(0, 237, 0, 50)
Execute9.Font = Enum.Font.SourceSans
Execute9.Text = "FE Anime Fight (Gale script)"
Execute9.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute9.TextSize = 21.000
Execute9.MouseButton1Down:connect(function()
	-----------------
	repeat wait() until _G.MSG ~= nil
	repeat wait() until _G.MSG.Text == ""
		local t = {}
		local string = string
		local math = math
		local table = table
		local error = error
		local tonumber = tonumber
		local tostring = tostring
		local type = type
		local setmetatable = setmetatable
		local pairs = pairs
		local ipairs = ipairs
		local assert = assert


		local StringBuilder = {
			buffer = {}
		}

		function StringBuilder:New()
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.buffer = {}
			return o
		end

		function StringBuilder:Append(s)
			self.buffer[#self.buffer+1] = s
		end

		function StringBuilder:ToString()
			return table.concat(self.buffer)
		end

		local JsonWriter = {
			backslashes = {
				['\b'] = "\\b",
				['\t'] = "\\t",
				['\n'] = "\\n",
				['\f'] = "\\f",
				['\r'] = "\\r",
				['"'] = "\\\"",
				['\\'] = "\\\\",
				['/'] = "\\/"
			}
		}

		function JsonWriter:New()
			local o = {}
			o.writer = StringBuilder:New()
			setmetatable(o, self)
			self.__index = self
			return o
		end

		function JsonWriter:Append(s)
			self.writer:Append(s)
		end

		function JsonWriter:ToString()
			return self.writer:ToString()
		end

		function JsonWriter:Write(o)
			local t = type(o)
			if t == "nil" then
				self:WriteNil()
			elseif t == "boolean" then
				self:WriteString(o)
			elseif t == "number" then
				self:WriteString(o)
			elseif t == "string" then
				self:ParseString(o)
			elseif t == "table" then
				self:WriteTable(o)
			elseif t == "function" then
				self:WriteFunction(o)
			elseif t == "thread" then
				self:WriteError(o)
			elseif t == "userdata" then
				self:WriteError(o)
			end
		end

		function JsonWriter:WriteNil()
			self:Append("null")
		end

		function JsonWriter:WriteString(o)
			self:Append(tostring(o))
		end

		function JsonWriter:ParseString(s)
			self:Append('"')
			self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
				local c = self.backslashes[n]
				if c then return c end
				return string.format("\\u%.4X", string.byte(n))
			end))
			self:Append('"')
		end

		function JsonWriter:IsArray(t)
			local count = 0
			local isindex = function(k)
				if type(k) == "number" and k > 0 then
					if math.floor(k) == k then
						return true
					end
				end
				return false
			end
			for k,v in pairs(t) do
				if not isindex(k) then
					return false, '{', '}'
				else
					count = math.max(count, k)
				end
			end
			return true, '[', ']', count
		end

		function JsonWriter:WriteTable(t)
			local ba, st, et, n = self:IsArray(t)
			self:Append(st)
			if ba then
				for i = 1, n do
					self:Write(t[i])
					if i < n then
						self:Append(',')
					end
				end
			else
				local first = true;
				for k, v in pairs(t) do
					if not first then
						self:Append(',')
					end
					first = false;
					self:ParseString(k)
					self:Append(':')
					self:Write(v)
				end
			end
			self:Append(et)
		end

		function JsonWriter:WriteError(o)
			error(string.format(
				"Encoding of %s unsupported",
				tostring(o)))
		end

		function JsonWriter:WriteFunction(o)
			if o == Null then
				self:WriteNil()
			else
				self:WriteError(o)
			end
		end

		local StringReader = {
			s = "",
			i = 0
		}

		function StringReader:New(s)
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.s = s or o.s
			return o
		end

		function StringReader:Peek()
			local i = self.i + 1
			if i <= #self.s then
				return string.sub(self.s, i, i)
			end
			return nil
		end

		function StringReader:Next()
			self.i = self.i+1
			if self.i <= #self.s then
				return string.sub(self.s, self.i, self.i)
			end
			return nil
		end

		function StringReader:All()
			return self.s
		end

		local JsonReader = {
			escapes = {
				['t'] = '\t',
				['n'] = '\n',
				['f'] = '\f',
				['r'] = '\r',
				['b'] = '\b',
			}
		}

		function JsonReader:New(s)
			local o = {}
			o.reader = StringReader:New(s)
			setmetatable(o, self)
			self.__index = self
			return o;
		end

		function JsonReader:Read()
			self:SkipWhiteSpace()
			local peek = self:Peek()
			if peek == nil then
				error(string.format(
					"Nil string: '%s'",
					self:All()))
			elseif peek == '{' then
				return self:ReadObject()
			elseif peek == '[' then
				return self:ReadArray()
			elseif peek == '"' then
				return self:ReadString()
			elseif string.find(peek, "[%+%-%d]") then
				return self:ReadNumber()
			elseif peek == 't' then
				return self:ReadTrue()
			elseif peek == 'f' then
				return self:ReadFalse()
			elseif peek == 'n' then
				return self:ReadNull()
			elseif peek == '/' then
				self:ReadComment()
				return self:Read()
			else
				return nil
			end
		end

		function JsonReader:ReadTrue()
			self:TestReservedWord{'t','r','u','e'}
			return true
		end

		function JsonReader:ReadFalse()
			self:TestReservedWord{'f','a','l','s','e'}
			return false
		end

		function JsonReader:ReadNull()
			self:TestReservedWord{'n','u','l','l'}
			return nil
		end

		function JsonReader:TestReservedWord(t)
			for i, v in ipairs(t) do
				if self:Next() ~= v then
					error(string.format(
						"Error reading '%s': %s",
						table.concat(t),
						self:All()))
				end
			end
		end

		function JsonReader:ReadNumber()
			local result = self:Next()
			local peek = self:Peek()
			while peek ~= nil and string.find(
				peek,
				"[%+%-%d%.eE]") do
				result = result .. self:Next()
				peek = self:Peek()
			end
			result = tonumber(result)
			if result == nil then
				error(string.format(
					"Invalid number: '%s'",
					result))
			else
				return result
			end
		end

		function JsonReader:ReadString()
			local result = ""
			assert(self:Next() == '"')
			while self:Peek() ~= '"' do
				local ch = self:Next()
				if ch == '\\' then
					ch = self:Next()
					if self.escapes[ch] then
						ch = self.escapes[ch]
					end
				end
				result = result .. ch
			end
			assert(self:Next() == '"')
			local fromunicode = function(m)
				return string.char(tonumber(m, 16))
			end
			return string.gsub(
				result,
				"u%x%x(%x%x)",
				fromunicode)
		end

		function JsonReader:ReadComment()
			assert(self:Next() == '/')
			local second = self:Next()
			if second == '/' then
				self:ReadSingleLineComment()
			elseif second == '*' then
				self:ReadBlockComment()
			else
				error(string.format(
					"Invalid comment: %s",
					self:All()))
			end
		end

		function JsonReader:ReadBlockComment()
			local done = false
			while not done do
				local ch = self:Next()
				if ch == '*' and self:Peek() == '/' then
					done = true
				end
				if not done and
					ch == '/' and
					self:Peek() == "*" then
					error(string.format(
						"Invalid comment: %s, '/*' illegal.",
						self:All()))
				end
			end
			self:Next()
		end

		function JsonReader:ReadSingleLineComment()
			local ch = self:Next()
			while ch ~= '\r' and ch ~= '\n' do
				ch = self:Next()
			end
		end

		function JsonReader:ReadArray()
			local result = {}
			assert(self:Next() == '[')
			local done = false
			if self:Peek() == ']' then
				done = true;
			end
			while not done do
				local item = self:Read()
				result[#result+1] = item
				self:SkipWhiteSpace()
				if self:Peek() == ']' then
					done = true
				end
				if not done then
					local ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' due to: '%s'",
							self:All(), ch))
					end
				end
			end
			assert(']' == self:Next())
			return result
		end

		function JsonReader:ReadObject()
			local result = {}
			assert(self:Next() == '{')
			local done = false
			if self:Peek() == '}' then
				done = true
			end
			while not done do
				local key = self:Read()
				if type(key) ~= "string" then
					error(string.format(
						"Invalid non-string object key: %s",
						key))
				end
				self:SkipWhiteSpace()
				local ch = self:Next()
				if ch ~= ':' then
					error(string.format(
						"Invalid object: '%s' due to: '%s'",
						self:All(),
						ch))
				end
				self:SkipWhiteSpace()
				local val = self:Read()
				result[key] = val
				self:SkipWhiteSpace()
				if self:Peek() == '}' then
					done = true
				end
				if not done then
					ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' near: '%s'",
							self:All(),
							ch))
					end
				end
			end
			assert(self:Next() == "}")
			return result
		end

		function JsonReader:SkipWhiteSpace()
			local p = self:Peek()
			while p ~= nil and string.find(p, "[%s/]") do
				if p == '/' then
					self:ReadComment()
				else
					self:Next()
				end
				p = self:Peek()
			end
		end

		function JsonReader:Peek()
			return self.reader:Peek()
		end

		function JsonReader:Next()
			return self.reader:Next()
		end

		function JsonReader:All()
			return self.reader:All()
		end

		function Encode(o)
			local writer = JsonWriter:New()
			writer:Write(o)
			return writer:ToString()
		end

		function Decode(s)
			local reader = JsonReader:New(s)
			return reader:Read()
		end

		function Null()
			return Null
		end
		-------------------- End JSON Parser ------------------------

		t.DecodeJSON = function(jsonString)
			pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

			if type(jsonString) == "string" then
				return Decode(jsonString)
			end
			print("RbxUtil.DecodeJSON expects string argument!")
			return nil
		end

		t.EncodeJSON = function(jsonTable)
			pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
			return Encode(jsonTable)
		end








		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--makes a wedge at location x, y, z
		--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
		--returns true if made a wedge, false if the cell remains a block
		t.MakeWedge = function(x, y, z, defaultmaterial)
			return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
		end

		t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
			local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
			if not terrain then return end

			assert(regionToSelect)
			assert(color)

			if not type(regionToSelect) == "Region3" then
				error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
			end
			if not type(color) == "BrickColor" then
				error("color (second arg), should be of type BrickColor, but is type",type(color))
			end

			-- frequently used terrain calls (speeds up call, no lookup necessary)
			local GetCell = terrain.GetCell
			local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
			local CellCenterToWorld = terrain.CellCenterToWorld
			local emptyMaterial = Enum.CellMaterial.Empty

			-- container for all adornments, passed back to user
			local selectionContainer = Instance.new("Model")
			selectionContainer.Name = "SelectionContainer"
			selectionContainer.Archivable = false
			if selectionParent then
				selectionContainer.Parent = selectionParent
			else
				selectionContainer.Parent = game:GetService("Workspace")
			end

			local updateSelection = nil -- function we return to allow user to update selection
			local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
			local aliveCounter = 0 -- helper for currentKeepAliveTag
			local lastRegion = nil -- used to stop updates that do nothing
			local adornments = {} -- contains all adornments
			local reusableAdorns = {}

			local selectionPart = Instance.new("Part")
			selectionPart.Name = "SelectionPart"
			selectionPart.Transparency = 1
			selectionPart.Anchored = true
			selectionPart.Locked = true
			selectionPart.CanCollide = false
			selectionPart.Size = Vector3.new(4.2,4.2,4.2)

			local selectionBox = Instance.new("SelectionBox")

			-- srs translation from region3 to region3int16
			local function Region3ToRegion3int16(region3)
				local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
				local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

				local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
				local highCell = WorldToCellPreferSolid(terrain, theHighVec)

				local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
				local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

				return Region3int16.new(lowIntVec,highIntVec)
			end

			-- helper function that creates the basis for a selection box
			function createAdornment(theColor)
				local selectionPartClone = nil
				local selectionBoxClone = nil

				if #reusableAdorns > 0 then
					selectionPartClone = reusableAdorns[1]["part"]
					selectionBoxClone = reusableAdorns[1]["box"]
					table.remove(reusableAdorns,1)

					selectionBoxClone.Visible = true
				else
					selectionPartClone = selectionPart:Clone()
					selectionPartClone.Archivable = false

					selectionBoxClone = selectionBox:Clone()
					selectionBoxClone.Archivable = false

					selectionBoxClone.Adornee = selectionPartClone
					selectionBoxClone.Parent = selectionContainer

					selectionBoxClone.Adornee = selectionPartClone

					selectionBoxClone.Parent = selectionContainer
				end

				if theColor then
					selectionBoxClone.Color = theColor
				end

				return selectionPartClone, selectionBoxClone
			end

			-- iterates through all current adornments and deletes any that don't have latest tag
			function cleanUpAdornments()
				for cellPos, adornTable in pairs(adornments) do

					if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
						adornTable.SelectionBox.Visible = false
						table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
						adornments[cellPos] = nil
					end
				end
			end

			-- helper function to update tag
			function incrementAliveCounter()
				aliveCounter = aliveCounter + 1
				if aliveCounter > 1000000 then
					aliveCounter = 0
				end
				return aliveCounter
			end

			-- finds full cells in region and adorns each cell with a box, with the argument color
			function adornFullCellsInRegion(region, color)
				local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
				local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

				local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
				local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

				currentKeepAliveTag = incrementAliveCounter()
				for y = cellPosBegin.y, cellPosEnd.y do
					for z = cellPosBegin.z, cellPosEnd.z do
						for x = cellPosBegin.x, cellPosEnd.x do
							local cellMaterial = GetCell(terrain, x, y, z)

							if cellMaterial ~= emptyMaterial then
								local cframePos = CellCenterToWorld(terrain, x, y, z)
								local cellPos = Vector3int16.new(x,y,z)

								local updated = false
								for cellPosAdorn, adornTable in pairs(adornments) do
									if cellPosAdorn == cellPos then
										adornTable.KeepAlive = currentKeepAliveTag
										if color then
											adornTable.SelectionBox.Color = color
										end
										updated = true
										break
									end
								end

								if not updated then
									local selectionPart, selectionBox = createAdornment(color)
									selectionPart.Size = Vector3.new(4,4,4)
									selectionPart.CFrame = CFrame.new(cframePos)
									local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
									adornments[cellPos] = adornTable
								end
							end
						end
					end
				end
				cleanUpAdornments()
			end


			------------------------------------- setup code ------------------------------
			lastRegion = regionToSelect

			if selectEmptyCells then -- use one big selection to represent the area selected
				local selectionPart, selectionBox = createAdornment(color)

				selectionPart.Size = regionToSelect.Size
				selectionPart.CFrame = regionToSelect.CFrame

				adornments.SelectionPart = selectionPart
				adornments.SelectionBox = selectionBox

				updateSelection =
					function (newRegion, color)
					if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						selectionPart.Size = newRegion.Size
						selectionPart.CFrame = newRegion.CFrame
					end
					if color then
						selectionBox.Color = color
					end
				end
			else -- use individual cell adorns to represent the area selected
				adornFullCellsInRegion(regionToSelect, color)
				updateSelection =
					function (newRegion, color)
					if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						adornFullCellsInRegion(newRegion, color)
					end
				end

			end

			local destroyFunc = function()
				updateSelection = nil
				if selectionContainer then selectionContainer:Destroy() end
				adornments = nil
			end

			return updateSelection, destroyFunc
		end

		-----------------------------Terrain Utilities End-----------------------------







		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Signal class begin------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
Arguments: The function to connect to.
Returns: A new connection object which can be used to disconnect the connection
Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
NOT mean that the first will be called before the second as a result of a call to |fire|.
 
Method :disconnect()
Arguments: None
Returns: None
Description: Disconnects all of the functions connected to this signal.
 
Method :fire( ... )
Arguments: Any arguments are accepted
Returns: None
Description: Calls all of the currently connected functions with the given arguments.
 
Method :wait()
Arguments: None
Returns: The arguments given to fire
Description: This call blocks until
]]

		function t.CreateSignal()
			local this = {}

			local mBindableEvent = Instance.new('BindableEvent')
			local mAllCns = {} --all connection objects returned by mBindableEvent::connect

			--main functions
			function this:connect(func)
				if self ~= this then error("connect must be called with `:`, not `.`", 2) end
				if type(func) ~= 'function' then
					error("Argument #1 of connect must be a function, got a "..type(func), 2)
				end
				local cn = mBindableEvent.Event:Connect(func)
				mAllCns[cn] = true
				local pubCn = {}
				function pubCn:disconnect()
					cn:Disconnect()
					mAllCns[cn] = nil
				end
				pubCn.Disconnect = pubCn.disconnect

				return pubCn
			end

			function this:disconnect()
				if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
				for cn, _ in pairs(mAllCns) do
					cn:Disconnect()
					mAllCns[cn] = nil
				end
			end

			function this:wait()
				if self ~= this then error("wait must be called with `:`, not `.`", 2) end
				return mBindableEvent.Event:Wait()
			end

			function this:fire(...)
				if self ~= this then error("fire must be called with `:`, not `.`", 2) end
				mBindableEvent:Fire(...)
			end

			this.Connect = this.connect
			this.Disconnect = this.disconnect
			this.Wait = this.wait
			this.Fire = this.fire

			return this
		end

		------------------------------------------------- Sigal class End ------------------------------------------------------




		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		-----------------------------------------------Create Function Begins---------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in
which case it simply creates an object of the given type, or a table argument that may contain several types of data,
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
|Create| call's body.
 
2) An integral key mapping to another Instance:
Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
need for temporary variables to store references to those objects.
 
3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy
for those who really want such a functionality. The name of the event whose name is passed to
Create.E( string )
 
4) A key which is the Create function itself, and a value which is a function
The function will be run with the argument of the object itself after all other initialization of the object is
done by create. This provides a way to do arbitrary things involving the object from withing the create
hierarchy.
Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the
constructor callback function is possible, it is probably not a good design choice.
Note: Since the constructor function is called after all other initialization, a Create block cannot have two
constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.
 
 
Some example usages:
 
A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
Name = 'A New model',
Parent = game.Workspace,
}
 
 
An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
|-ObjectValue
| |
| `-BoolValueChild
`-IntValue
 
local model = Create'Model'{
Name = 'Model_Container',
Create'ObjectValue'{
Create'BoolValue'{
Name = 'BoolValueChild',
},
},
Create'IntValue'{},
}
 
 
An example using the event syntax:
 
local part = Create'Part'{
[Create.E'Touched'] = function(part)
print("I was touched by "..part.Name)
end,
}
 
 
An example using the general constructor syntax:
 
local model = Create'Part'{
[Create] = function(this)
print("Constructor running!")
this.Name = GetGlobalFoosAndBars(this)
end,
}
 
 
Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
any unexpected behavior. EG:
local partCreatingFunction = Create'Part'
local part = partCreatingFunction()
]]

		--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
		--will be created in several steps rather than as a single function declaration.
		local function Create_PrivImpl(objectType)
			if type(objectType) ~= 'string' then
				error("Argument of Create must be a string", 2)
			end
			--return the proxy function that gives us the nice Create'string'{data} syntax
			--The first function call is a function call using Lua's single-string-argument syntax
			--The second function call is using Lua's single-table-argument syntax
			--Both can be chained together for the nice effect.
			return function(dat)
				--default to nothing, to handle the no argument given case
				dat = dat or {}

				--make the object to mutate
				local obj = Instance.new(objectType)
				local parent = nil

				--stored constructor function to be called after other initialization
				local ctor = nil

				for k, v in pairs(dat) do
					--add property
					if type(k) == 'string' then
						if k == 'Parent' then
							-- Parent should always be set last, setting the Parent of a new object
							-- immediately makes performance worse for all subsequent property updates.
							parent = v
						else
							obj[k] = v
						end


						--add child
					elseif type(k) == 'number' then
						if type(v) ~= 'userdata' then
							error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
						end
						v.Parent = obj


						--event connect
					elseif type(k) == 'table' and k.__eventname then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
got: "..tostring(v), 2)
						end
						obj[k.__eventname]:connect(v)


						--define constructor function
					elseif k == t.Create then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
got: "..tostring(v), 2)
						elseif ctor then
							--ctor already exists, only one allowed
							error("Bad entry in Create body: Only one constructor function is allowed", 2)
						end
						ctor = v


					else
						error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
					end
				end

				--apply constructor function if it exists
				if ctor then
					ctor(obj)
				end

				if parent then
					obj.Parent = parent
				end

				--return the completed object
				return obj
			end
		end

		--now, create the functor:
		t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

		--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
		--function can recognize as special.
		t.Create.E = function(eventName)
			return {__eventname = eventName}
		end

		-------------------------------------------------Create function End----------------------------------------------------




		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Documentation Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------

		t.Help =
			function(funcNameOrFunc)
			--input argument can be a string or a function. Should return a description (of arguments and expected side effects)
			if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
				return "Function DecodeJSON. " ..
					"Arguments: (string). " ..
					"Side effect: returns a table with all parsed JSON values"
			end
			if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
				return "Function EncodeJSON. " ..
					"Arguments: (table). " ..
					"Side effect: returns a string composed of argument table in JSON data format"
			end
			if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
				return "Function MakeWedge. " ..
					"Arguments: (x, y, z, [default material]). " ..
					"Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
					"parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
					"Returns true if made a wedge, false if the cell remains a block "
			end
			if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
				return "Function SelectTerrainRegion. " ..
					"Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
					"Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
					"(this should be a region3 value). The selection box color is detemined by the color argument " ..
					"(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
					"SelectEmptyCells is bool, when true will select all cells in the " ..
					"region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
					"arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
					"Also returns a second function that takes no arguments and destroys the selection"
			end
			if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
				return "Function CreateSignal. "..
					"Arguments: None. "..
					"Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
					"used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
					"Lua code. "..
					"Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
					"For more info you can pass the method name to the Help function, or view the wiki page "..
					"for this library. EG: Help('Signal:connect')."
			end
			if funcNameOrFunc == "Signal:connect" then
				return "Method Signal:connect. "..
					"Arguments: (function handler). "..
					"Return: A connection object which can be used to disconnect the connection to this handler. "..
					"Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
					"handler function will be called with the arguments passed to |fire|."
			end
			if funcNameOrFunc == "Signal:wait" then
				return "Method Signal:wait. "..
					"Arguments: None. "..
					"Returns: The arguments passed to the next call to |fire|. "..
					"Description: This call does not return until the next call to |fire| is made, at which point it "..
					"will return the values which were passed as arguments to that |fire| call."
			end
			if funcNameOrFunc == "Signal:fire" then
				return "Method Signal:fire. "..
					"Arguments: Any number of arguments of any type. "..
					"Returns: None. "..
					"Description: This call will invoke any connected handler functions, and notify any waiting code "..
					"attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
					"to handlers are made asynchronously, so this call will return immediately regardless of how long "..
					"it takes the connected handler functions to complete."
			end
			if funcNameOrFunc == "Signal:disconnect" then
				return "Method Signal:disconnect. "..
					"Arguments: None. "..
					"Returns: None. "..
					"Description: This call disconnects all handlers attacched to this function, note however, it "..
					"does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
					"can also be called on the connection object which is returned from Signal:connect to only "..
					"disconnect a single handler, as opposed to this method, which will disconnect all handlers."
			end
			if funcNameOrFunc == "Create" then
				return "Function Create. "..
					"Arguments: A table containing information about how to construct a collection of objects. "..
					"Returns: The constructed objects. "..
					"Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
					"is best described via example, please see the wiki page for a description of how to use it."
			end
		end

		--------------------------------------------Documentation Ends----------------------------------------------------------

		return t
	end

	--[[ Name : Gale Fighter ]]--
	-------------------------------------------------------
	--A Collaboration Between makhail07 and KillerDarkness0105

	--Base Animaion by makhail07, attacks by KillerDarkness0105
	-------------------------------------------------------


	local FavIDs = {
		340106355, --Nefl Crystals
		927529620, --Dimension
		876981900, --Fantasy
		398987889, --Ordinary Days
		1117396305, --Oh wait, it's you.
		885996042, --Action Winter Journey
		919231299, --Sprawling Idiot Effigy
		743466274, --Good Day Sunshine
		727411183, --Knife Fight
		1402748531, --The Earth Is Counting On You!
		595230126 --Robot Language
	}



	--The reality of my life isn't real but a Universe -makhail07
	wait(0.2)
	local plr = game:GetService("Players").LocalPlayer
	print('Local User is '..plr.Name)
	print('Gale Fighter Loaded')
	print('The Fighter that is as fast as wind, a true Fighter')
	local char = plr.Character.NullwareReanim
	local hum = char.Humanoid
	local hed = char.Head
	local root = char.HumanoidRootPart
	local rootj = root.RootJoint
	local tors = char.Torso
	local ra = char["Right Arm"]
	local la = char["Left Arm"]
	local rl = char["Right Leg"]
	local ll = char["Left Leg"]
	local neck = tors["Neck"]
	local mouse = plr:GetMouse()
	local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
	local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
	local maincolor = BrickColor.new("Institutional white")
	hum.MaxHealth = 200
	hum.Health = 200

	local hrp = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart

	hrp.Name = "HumanoidRootPart"
	hrp.Transparency = 0.5
	hrp.Anchored = false
	if hrp:FindFirstChildOfClass("AlignPosition") then
		hrp:FindFirstChildOfClass("AlignPosition"):Destroy()
	end
	if hrp:FindFirstChildOfClass("AlignOrientation") then
		hrp:FindFirstChildOfClass("AlignOrientation"):Destroy()
	end
	local bp = Instance.new("BodyPosition", hrp)
	bp.Position = hrp.Position
	bp.D = 9999999
	bp.P = 999999999999999
	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
	local flinger = Instance.new("BodyAngularVelocity",hrp)
	flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	flinger.P = 1000000000000000000000000000
	flinger.AngularVelocity = Vector3.new(10000,10000,10000)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			bp.Position = game:GetService("Players").LocalPlayer.Character["NullwareReanim"].Torso.Position
		end
	end)

	-------------------------------------------------------
	--Start Good Stuff--
	-------------------------------------------------------
	cam = game.Workspace.CurrentCamera
	CF = CFrame.new
	angles = CFrame.Angles
	attack = false
	Euler = CFrame.fromEulerAnglesXYZ
	Rad = math.rad
	IT = Instance.new
	BrickC = BrickColor.new
	Cos = math.cos
	Acos = math.acos
	Sin = math.sin
	Asin = math.asin
	Abs = math.abs
	Mrandom = math.random
	Floor = math.floor
	-------------------------------------------------------
	--End Good Stuff--
	-------------------------------------------------------
	necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	RSH, LSH = nil, nil
	RW = Instance.new("Weld")
	LW = Instance.new("Weld")
	RH = tors["Right Hip"]
	LH = tors["Left Hip"]
	RSH = tors["Right Shoulder"]
	LSH = tors["Left Shoulder"]
	RSH.Parent = nil
	LSH.Parent = nil
	RW.Name = "RW"
	RW.Part0 = tors
	RW.C0 = CF(1.5, 0.5, 0)
	RW.C1 = CF(0, 0.5, 0)
	RW.Part1 = ra
	RW.Parent = tors
	LW.Name = "LW"
	LW.Part0 = tors
	LW.C0 = CF(-1.5, 0.5, 0)
	LW.C1 = CF(0, 0.5, 0)
	LW.Part1 = la
	LW.Parent = tors
	vt = Vector3.new
	Effects = {}
	-------------------------------------------------------
	--Start HeartBeat--
	-------------------------------------------------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")

	frame = 1 / 90
	tf = 0
	allowframeloss = false
	tossremainder = false


	lastframe = tick()
	script.Heartbeat:Fire()


	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	-------------------------------------------------------
	--End HeartBeat--
	-------------------------------------------------------



	-------------------------------------------------------
	--Start Combo Function--
	-------------------------------------------------------
	local comboing = false
	local combohits = 0
	local combotime = 0
	local maxtime = 65



	function sandbox(var,func)
		local env = getfenv(func)
		local newenv = setmetatable({},{
			__index = function(self,k)
				if k=="script" then
					return var
				else
					return env[k]
				end
			end,
		})
		setfenv(func,newenv)
		return func
	end
	cors = {}
	mas = Instance.new("Model",game:GetService("Lighting"))
	comboframe = Instance.new("ScreenGui")
	Frame1 = Instance.new("Frame")
	Frame2 = Instance.new("Frame")
	TextLabel3 = Instance.new("TextLabel")
	comboframe.Name = "combinserter"
	comboframe.Parent = mas
	Frame1.Name = "combtimegui"
	Frame1.Parent = comboframe
	Frame1.Size = UDim2.new(0, 300, 0, 14)
	Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
	Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
	Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
	Frame1.BorderSizePixel = 5
	Frame2.Name = "combtimeoverlay"
	Frame2.Parent = Frame1
	Frame2.Size = UDim2.new(0, 0, 0, 14)
	Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
	Frame2.ZIndex = 2
	TextLabel3.Parent = Frame2
	TextLabel3.Transparency = 0
	TextLabel3.Size = UDim2.new(0, 300, 0, 50)
	TextLabel3.Text ="Hits: "..combohits
	TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
	TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
	TextLabel3.BackgroundTransparency = 1
	TextLabel3.Font = Enum.Font.Bodoni
	TextLabel3.FontSize = Enum.FontSize.Size60
	TextLabel3.TextColor3 = Color3.new(0, 1, 0)
	TextLabel3.TextStrokeTransparency = 0
	gui = game:GetService("Players").LocalPlayer.PlayerGui
	for i,v in pairs(mas:GetChildren()) do
		v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
		pcall(function() v:MakeJoints() end)
	end
	mas:Destroy()
	for i,v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end





	coroutine.resume(coroutine.create(function()
		while true do
			wait()


			if combotime>65 then
				combotime = 65
			end





			if combotime>.1 and comboing == true then
				TextLabel3.Transparency = 0
				TextLabel3.TextStrokeTransparency = 0
				TextLabel3.BackgroundTransparency = 1
				Frame1.Transparency = 0
				Frame2.Transparency = 0
				TextLabel3.Text ="Hits: "..combohits
				combotime = combotime - .34
				Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
			end




			if combotime<.1 then
				TextLabel3.BackgroundTransparency = 1
				TextLabel3.Transparency = 1
				TextLabel3.TextStrokeTransparency = 1

				Frame2.Size = UDim2.new(0, 0, 0, 14)
				combotime = 0
				comboing = false
				Frame1.Transparency = 1
				Frame2.Transparency = 1
				combohits = 0

			end
		end
	end))



	-------------------------------------------------------
	--End Combo Function--
	-------------------------------------------------------

	-------------------------------------------------------
	--Start Important Functions--
	-------------------------------------------------------
	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end
	function thread(f)
		coroutine.resume(coroutine.create(f))
	end
	function clerp(a, b, t)
		local qa = {
			QuaternionFromCFrame(a)
		}
		local qb = {
			QuaternionFromCFrame(b)
		}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end
	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m00 < m11 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end
	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 1.0E-4 then
			if 1 - cosTheta > 1.0E-4 then
				local theta = math.acos(cosTheta)
				local invSinTheta = 1 / Sin(theta)
				startInterp = Sin((1 - t) * theta) * invSinTheta
				finishInterp = Sin(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		elseif 1 + cosTheta > 1.0E-4 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((t - 1) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end
	function rayCast(Position, Direction, Range, Ignore)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
	end
	local RbxUtility = LoadLibrary("RbxUtility")
	local Create = RbxUtility.Create

	-------------------------------------------------------
	--Start Damage Function--
	-------------------------------------------------------

	-------------------------------------------------------
	--End Damage Function--
	-------------------------------------------------------

	-------------------------------------------------------
	--Start Damage Function Customization--
	-------------------------------------------------------
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = (1 / 30)
		local Pos = (Pos or Vector3.new(0, 0, 0))
		local Text = (Text or "")
		local Time = (Time or 2)
		local Color = (Color or Color3.new(1, 0, 1))
		local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui"){
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart,
		}
		local TextLabel = Create("TextLabel"){
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			Font = "Bodoni",
			TextColor3 = Color,
			TextScaled = true,
			TextStrokeColor3 = Color3.fromRGB(0,0,0),
			Parent = BillboardGui,
		}
		game.Debris:AddItem(EffectPart, (Time))
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = (Time / Rate)
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = (Frame / Frames)
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	-------------------------------------------------------
	--End Damage Function Customization--
	-------------------------------------------------------

	CFuncs = {
		Part = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part")({
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material
				})
				RemoveOutlines(Part)
				return Part
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Weld = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld")({
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1
				})
				return Weld
			end
		},
		Sound = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound")({
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace
					})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 6)
				end))
			end
		},
		ParticleEmitter = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter")({
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread
				})
				return fp
			end
		}
	}
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			formFactor = FormFactor,
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end


	-------------------------------------------------------
	--Start Effect Function--
	-------------------------------------------------------
	EffectModel = Instance.new("Model", char)
	Effects = {
		Block = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				if Type == 1 or Type == nil then
					table.insert(Effects, {
						prt,
						"Block1",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				elseif Type == 2 then
					table.insert(Effects, {
						prt,
						"Block2",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				else
					table.insert(Effects, {
						prt,
						"Block3",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			end
		},
		Sphere = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Cylinder = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Wave = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3 / 60,
					y3 / 60,
					z3 / 60,
					msh
				})
			end
		},
		Ring = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Break = {
			Create = function(brickcolor, cframe, x1, y1, z1)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
				prt.Anchored = true
				prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				local num = math.random(10, 50) / 1000
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Shatter",
					num,
					prt.CFrame,
					math.random() - math.random(),
					0,
					math.random(50, 100) / 100
				})
			end
		},
		Spiral = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Push = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		}
	}
	function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
		local fp = IT("Part")
		fp.formFactor = formfactor
		fp.Parent = parent
		fp.Reflectance = reflectance
		fp.Transparency = transparency
		fp.CanCollide = false
		fp.Locked = true
		fp.BrickColor = brickcolor
		fp.Name = name
		fp.Size = size
		fp.Position = tors.Position
		RemoveOutlines(fp)
		fp.Material = "SmoothPlastic"
		fp:BreakJoints()
		return fp
	end

	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh = IT(Mesh)
		mesh.Parent = part
		if Mesh == "SpecialMesh" then
			mesh.MeshType = meshtype
			if meshid ~= "nil" then
				mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset = offset
		mesh.Scale = scale
		return mesh
	end

	function Magic(bonuspeed, type, pos, scale, value, color, MType)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = MType
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function Eviscerate(dude)
		if dude.Name ~= char then
			local bgf = IT("BodyGyro", dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
			local val = IT("BoolValue", dude)
			val.Name = "IsHit"
			local ds = coroutine.wrap(function()
				dude:WaitForChild("Head"):BreakJoints()
				wait(0.5)
				target = nil
				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								local PartEmmit1 = IT("ParticleEmitter", v)
								PartEmmit1.LightEmission = 1
								PartEmmit1.Texture = "rbxassetid://284205403"
								PartEmmit1.Color = ColorSequence.new(maincolor.Color)
								PartEmmit1.Rate = 150
								PartEmmit1.Lifetime = NumberRange.new(1)
								PartEmmit1.Size = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0.75, 0),
									NumberSequenceKeypoint.new(1, 0, 0)
								})
								PartEmmit1.Transparency = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0, 0),
									NumberSequenceKeypoint.new(1, 1, 0)
								})
								PartEmmit1.Speed = NumberRange.new(0, 0)
								PartEmmit1.VelocitySpread = 30000
								PartEmmit1.Rotation = NumberRange.new(-500, 500)
								PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
								local BodPoss = IT("BodyPosition", v)
								BodPoss.P = 3000
								BodPoss.D = 1000
								BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
								v.Color = maincolor.Color
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v.Transparency = v.Transparency + 0.08
									end
									wait(0.5)
									PartEmmit1.Enabled = false
									wait(3)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end

	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
				table.insert(List, v)
			end
		end
		return List
	end

	function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = MType
		rngm.Scale = Vector3.new(x1, y1, z1)
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				speeder = speeder - 0.01 * FastSpeed * bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function SoulSteal(dude)
		if dude.Name ~= char then
			local bgf = IT("BodyGyro", dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
			local val = IT("BoolValue", dude)
			val.Name = "IsHit"
			local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
			local soulst = coroutine.wrap(function()
				local soul = Instance.new("Part",dude)
				soul.Size = Vector3.new(1,1,1)
				soul.CanCollide = false
				soul.Anchored = false
				soul.Position = torso.Position
				soul.Transparency = 1
				local PartEmmit1 = IT("ParticleEmitter", soul)
				PartEmmit1.LightEmission = 1
				PartEmmit1.Texture = "rbxassetid://569507414"
				PartEmmit1.Color = ColorSequence.new(maincolor.Color)
				PartEmmit1.Rate = 250
				PartEmmit1.Lifetime = NumberRange.new(1.6)
				PartEmmit1.Size = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 1, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				PartEmmit1.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 0, 0),
					NumberSequenceKeypoint.new(1, 1, 0)
				})
				PartEmmit1.Speed = NumberRange.new(0, 0)
				PartEmmit1.VelocitySpread = 30000
				PartEmmit1.Rotation = NumberRange.new(-360, 360)
				PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
				local BodPoss = IT("BodyPosition", soul)
				BodPoss.P = 3000
				BodPoss.D = 1000
				BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
				BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
				wait(1.6)
				soul.Touched:connect(function(hit)
					if hit.Parent == char then
						soul:Destroy()
					end
				end)
				wait(1.2)
				while soul do
					swait()
					PartEmmit1.Color = ColorSequence.new(maincolor.Color)
					BodPoss.Position = tors.Position
				end
			end)
			soulst()
		end
	end




	--killer's effects





	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part"){
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material,
		}
		RemoveOutlines(Part)
		return Part
	end

	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh){
			Parent = Part,
			Offset = OffSet,
			Scale = Scale,
		}
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end



	function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		if Type == 1 or Type == nil then
			table.insert(Effects, {
				prt,
				"Block1",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		elseif Type == 2 then
			table.insert(Effects, {
				prt,
				"Block2",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	end

	function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end

	function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh,num)
			for i=0,1,delay do
				swait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,(math.random(0,1)+math.random())/5)
	end

	function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end

	function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end

	function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end


	function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end

	function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end

	function BreakEffect(brickcolor, cframe, x1, y1, z1)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
		local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		local num = math.random(10, 50) / 1000
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Shatter",
			num,
			prt.CFrame,
			math.random() - math.random(),
			0,
			math.random(50, 100) / 100
		})
	end





	so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			sou:play()
			game:GetService("Debris"):AddItem(sou,8)
		end))
	end


	--end of killer's effects


	function FaceMouse()
		local Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end
	-------------------------------------------------------
	--End Effect Function--
	-------------------------------------------------------
	function Cso(ID, PARENT, VOLUME, PITCH)
		local NSound = nil
		coroutine.resume(coroutine.create(function()
			NSound = IT("Sound", PARENT)
			NSound.Volume = VOLUME
			NSound.Pitch = PITCH
			NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
			swait()
			NSound:play()
			game:GetService("Debris"):AddItem(NSound, 10)
		end))
		return NSound
	end
	function CameraEnshaking(Length, Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1 * Intensity
			local rotM = 0.01 * Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05 * Intensity / Length
				rotM = rotM - 5.0E-4 * Intensity / Length
				hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
				cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
			end
			hum.CameraOffset = Vector3.new(0, 0, 0)
		end))
	end
	-------------------------------------------------------
	--End Important Functions--
	-------------------------------------------------------


	-------------------------------------------------------
	--Start Customization--
	-------------------------------------------------------
	local Player_Size = 1
	if Player_Size ~= 1 then
		root.Size = root.Size * Player_Size
		tors.Size = tors.Size * Player_Size
		hed.Size = hed.Size * Player_Size
		ra.Size = ra.Size * Player_Size
		la.Size = la.Size * Player_Size
		rl.Size = rl.Size * Player_Size
		ll.Size = ll.Size * Player_Size
		----------------------------------------------------------------------------------
		rootj.Parent = root
		neck.Parent = tors
		RW.Parent = tors
		LW.Parent = tors
		RH.Parent = tors
		LH.Parent = tors
		----------------------------------------------------------------------------------
		rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
		rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
		neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
		neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
		RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
		LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
		----------------------------------------------------------------------------------
		RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		--hat.Parent = Character
	end
	----------------------------------------------------------------------------------
	local SONG = 900817147 --900817147
	local SONG2 = 0
	local Music = Instance.new("Sound",tors)
	Music.Volume = 0.7
	Music.Looped = true
	Music.Pitch = 1 --Pitcher
	----------------------------------------------------------------------------------
	local equipped = false
	local idle = 0
	local change = 1
	local val = 0
	local toim = 0
	local idleanim = 0.4
	local sine = 0
	local Sit = 1
	local attacktype = 1
	local attackdebounce = false
	local euler = CFrame.fromEulerAnglesXYZ
	local cankick = false
	----------------------------------------------------------------------------------
	hum.WalkSpeed = 8
	hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
	local ANIMATOR = hum.Animator
	local ANIMATE = char.Animate
	ANIMATE.Parent = nil
	ANIMATOR.Parent = nil
	-------------------------------------------------------
	--End Customization--
	-------------------------------------------------------


	-------------------------------------------------------
	--Start Attacks N Stuff--
	-------------------------------------------------------

	--pls be proud mak i did my best



	function attackone()

		attack = true

		for i = 0, 1.35, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
		end

		so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))


		con5=ra.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true

					so("http://roblox.com/asset/?id=636494529",ra,2,1)

					RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
						end
					end))


					wait(0.34)
					attackdebounce = false

				end
			end
		end)
		for i = 0, 1.12, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
		end

		con5:Disconnect()
		attack = false

	end












	function attacktwo()

		attack = true

		for i = 0, 1.35, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
		end

		so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))


		con5=la.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true

					so("http://roblox.com/asset/?id=636494529",la,2,1)

					RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
						end
					end))


					wait(0.34)
					attackdebounce = false

				end
			end
		end)




		for i = 0, 1.12, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
		end

		con5:Disconnect()
		attack = false

	end





	function attackthree()

		attack = true


		for i = 0, 1.14, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
		end

		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true

					so("http://roblox.com/asset/?id=636494529",ll,2,1)

					RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
						end
					end))


					wait(0.34)
					attackdebounce = false

				end
			end
		end)

		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 9.14, 0.3 do
			swait()
			BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
		end
		attack = false
		con5:disconnect()
	end



	function attackfour()

		attack = true
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
		for i = 0, 5.14, 0.1 do
			swait()
			SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
		end
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		local velo=Instance.new("BodyVelocity")
		velo.velocity=vt(0,25,0)
		velo.P=8000
		velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
		velo.Parent=root
		game:GetService("Debris"):AddItem(velo,0.7)



		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529",rl,2,1)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
						end
					end))


					wait(0.14)
					attackdebounce = false
				end
			end
		end)

		for i = 0, 5.11, 0.15 do
			swait()
			BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
		end


		attack = false
		con5:disconnect()
	end





	local cooldown = false
	function quickkick()
		attack = true


		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true

					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
						end
					end))

					so("http://roblox.com/asset/?id=636494529",rl,2,1)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
						end
					end))


					wait(0.08)
					attackdebounce = false
				end
			end
		end)

		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 11.14, 0.3 do
			swait()
			root.Velocity = root.CFrame.lookVector * 30
			BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
		end
		attack = false
		con5:disconnect()
	end








	function Taunt()
		attack = true
		hum.WalkSpeed = 0
		Cso("1535995570", hed, 8.45, 1)
		for i = 0, 8.2, 0.1 do
			swait()
			hum.WalkSpeed = 0
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
			LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
		end
		attack = false
		hum.WalkSpeed = 8
	end







	function Hyperkickcombo()

		attack = true
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
		for i = 0, 7.14, 0.1 do
			swait()
			SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
		end
		local Cracking = Cso("292536356", tors, 10, 1)
		for i = 0, 7.14, 0.1 do
			swait()
			hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
			Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
			WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
			SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
		end
		Cracking.Playing = false
		so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
		local velo=Instance.new("BodyVelocity")
		velo.velocity=vt(0,27,0)
		velo.P=11000
		velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
		velo.Parent=root
		game:GetService("Debris"):AddItem(velo,1.24)



		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
						end
					end))


					wait(0.09)
					attackdebounce = false
				end
			end
		end)

		for i = 0, 9.11, 0.2 do
			swait()
			BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
		end




		con5:disconnect()






		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
						end
					end))


					wait(0.08)
					attackdebounce = false
				end
			end
		end)



		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 9.14, 0.3 do
			swait()
			root.Velocity = root.CFrame.lookVector * 20
			BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
		end



		con5:disconnect()



		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
						end
					end))


					wait(0.05)
					attackdebounce = false
				end
			end
		end)


		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 15.14, 0.32 do
			swait()
			root.Velocity = root.CFrame.lookVector * 20
			BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
		end

		attack = false
		con5:disconnect()

	end





	local ultra = false

	function Galekicks()

		attack = true
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		for i = 0, 1.65, 0.1 do
			swait()
			root.Velocity = root.CFrame.lookVector * 0
			SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
		end


		for i = 1, 17 do

			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))


						wait(0.05)
						attackdebounce = false
					end
				end
			end)

			for i = 0, .1, 0.2 do
				swait()
				BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
				root.Velocity = root.CFrame.lookVector * 10
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
			end

			so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))

			for i = 0, 0.4, 0.2 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end
			con5:disconnect()
		end


		u = mouse.KeyDown:connect(function(key)
			if key == 'r' and combohits >= 150 then
				ultra = true
				SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
			end
		end)
		wait(0.3)
		if ultra == true then
			combohits = 0
			wait(0.1)
			for i = 0, 1.65, 0.1 do
				swait()
				root.Velocity = root.CFrame.lookVector * 0
				SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end


			so("http://roblox.com/asset/?id=146094803",hed,1,1.2)

			for i = 1, 65 do
				--Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
				con5=hum.Touched:connect(function(hit)
					if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						if attackdebounce == false then
							attackdebounce = true
							coroutine.resume(coroutine.create(function()
								for i = 0,1.5,0.1 do
									swait()
									hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
								end
							end))
							so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
							RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



							coroutine.resume(coroutine.create(function()
								for i = 0,1,0.1 do
									swait()
									hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
								end
							end))


							wait(0.05)
							attackdebounce = false
						end
					end
				end)

				for i = 0, .03, 0.1 do
					swait()
					BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
					root.Velocity = root.CFrame.lookVector * 10
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
				end

				so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))

				for i = 0, 0.07, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end
				con5:disconnect()
			end

			for i = 0, 1.65, 0.1 do
				swait()
				root.Velocity = root.CFrame.lookVector * 0
				SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end

			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								--hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529",rl,2,.63)
						RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))


						wait(0.05)
						attackdebounce = false
					end
				end
			end)

			so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
			SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)

			for i = 0, 2, 0.1 do
				swait()
				--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end
			SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)

			wait(0.25)
			con5:Disconnect()




			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true

						so("http://roblox.com/asset/?id=565207203",ll,7,0.63)

						RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
						RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
						SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
						SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
						SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
						WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)

						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
							end
						end))

						wait(0.06)
						attackdebounce = false

					end
				end
			end)

			coroutine.resume(coroutine.create(function()
				while ultra == true do
					swait()
					root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
				end
			end))


			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for i = 1,3 do
				for i = 0, 9.14, 0.45 do
					swait()
					root.Velocity = root.CFrame.lookVector * 30
					BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
				end
			end


			for i = 1,3 do
				for i = 0, 11.14, 0.45 do
					swait()
					root.Velocity = root.CFrame.lookVector * 30
					BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
				end



			end
			so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
			con5:disconnect()


		end -- combo hit end
		attack = false
		ultra = false
		u:disconnect()

	end




	-------------------------------------------------------
	--End Attacks N Stuff--
	-------------------------------------------------------
	mouse.KeyDown:connect(function(key)
		if string.byte(key) == 48 then
			Swing = 2
			hum.WalkSpeed = 24.82
		end
	end)
	mouse.KeyUp:connect(function(key)
		if string.byte(key) == 48 then
			Swing = 1
			hum.WalkSpeed = 8
		end
	end)







	mouse.Button1Down:connect(function()
		if attack==false then
			if attacktype==1 then
				attack=true
				attacktype=2
				attackone()
			elseif attacktype==2 then
				attack=true
				attacktype=3
				attacktwo()
			elseif attacktype==3 then
				attack=true
				attacktype=4
				attackthree()
			elseif attacktype==4 then
				attack=true
				attacktype=1
				attackfour()
			end
		end
	end)




	mouse.KeyDown:connect(function(key)
		if key == 'e' and attack == false and cankick == true and cooldown == false then
			quickkick()
			cooldown = true

			coroutine.resume(coroutine.create(function()
				wait(2)
				cooldown = false
			end))



		end
	end)








	mouse.KeyDown:connect(function(key)
		if attack == false then
			if key == 't' then
				Taunt()
			elseif key == 'f' then
				Hyperkickcombo()
			elseif key == 'r' then
				Galekicks()
			end
		end
	end)

	-------------------------------------------------------
	--Start Animations--
	-------------------------------------------------------
	print("By Makhail07 and KillerDarkness0105")
	print("Basic Animations by Makhail07")
	print("Attack Animations by KillerDarkness0105")
	print("This is pretty much our final script together")
	print("--------------------------------")
	print("Attacks")
	print("E in air: Quick Kicks")
	print("Left Mouse: 4 click combo")
	print("F: Hyper Kicks")
	print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
	print("--------------------------------")
	while true do
		swait()
		sine = sine + change
		local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
		local velderp = root.Velocity.y
		hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)

		if hitfloor == nil then
			cankick = true
		else
			cankick = false
		end


		if equipped == true or equipped == false then
			if attack == false then
				idle = idle + 1
			else
				idle = 0
			end
			if 1 < root.Velocity.y and hitfloor == nil then
				Anim = "Jump"
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
				end
			elseif -1 > root.Velocity.y and hitfloor == nil then
				Anim = "Fall"
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
				end
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
				change = 1
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				end
			elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
				Anim = "Walk"
				change = 1
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56) * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56) * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 75), 0.1)
				end
			elseif torvel >= 22 and hitfloor ~= nil then
				Anim = "Sprint"
				change = 1.35
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0) , Rad(-13) + la.RotVelocity.Y / 75), 0.15)
				end
			end
		end
		Music.SoundId = "rbxassetid://"..SONG
		Music.Looped = true
		Music.Pitch = 1
		Music.Volume = 0.7
		Music.Parent = tors
		Music:Resume()
		if 0 < #Effects then
			for e = 1, #Effects do
				if Effects[e] ~= nil then
					local Thing = Effects[e]
					if Thing ~= nil then
						local Part = Thing[1]
						local Mode = Thing[2]
						local Delay = Thing[3]
						local IncX = Thing[4]
						local IncY = Thing[5]
						local IncZ = Thing[6]
						if 1 >= Thing[1].Transparency then
							if Thing[2] == "Block1" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block2" then
								Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block3" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Cylinder" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Blood" then
								local Mesh = Thing[7]
								Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Elec" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Disappear" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Shatter" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
								Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
								Thing[6] = Thing[6] + Thing[5]
							end
						else
							Part.Parent = nil
							table.remove(Effects, e)
						end
					end
				end
			end
		end
	end
	-------------------------------------------------------
	--End Animations And Script--
	-------------------------------------------------------
end)

UICorner_10.Parent = Execute9

Execute10.Name = "Execute10"
Execute10.Parent = Main
Execute10.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute10.BorderSizePixel = 0
Execute10.Position = UDim2.new(0.54900682, 0, 0.508364558, 0)
Execute10.Size = UDim2.new(0, 238, 0, 50)
Execute10.Font = Enum.Font.SourceSans
Execute10.Text = "Grab Knife V4 (Non FE) But kills"
Execute10.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute10.TextSize = 21.000
Execute10.MouseButton1Down:connect(function()
	wait(0.5)
	math.randomseed(tick())
	local player = game.Players.LocalPlayer
	local rekt = {}
	local paralyzed = false
	local curpoint = nil
	local curpart = nil
	local finishnum = 1
	local zombiemode = false
	local zombies = {}
	local lastgui = nil
	local mouse = player:GetMouse()

	function getplr(char)
		local plr = nil
		for i,v in pairs(game.Players:GetChildren()) do
			if v.Character == char then
				plr = v
			end
		end
		return plr
	end

	function bleed(frick)
		while frick.Parent ~= nil do
			local reeee = coroutine.wrap(function()
				local thing = Instance.new('Part',game.Workspace)
				thing.Size = Vector3.new(0.2,0.2,0.2)
				thing.CFrame = frick.CFrame
				thing.Shape = Enum.PartType.Ball
				thing.CFrame = frick.CFrame
				thing.Transparency = 1
				thing.BrickColor = BrickColor.new('Maroon')
				thing.Material = Enum.Material.SmoothPlastic
				thing.Name = "Blood"
				thing.CanCollide =false
				local rawrxd = Instance.new('BodyForce',thing)
				rawrxd.Force = frick.CFrame.upVector*(math.random()*2)+Vector3.new(math.random(-5, 5)/10,1.5,0)
				local coru = coroutine.wrap(function()
					wait(0.01)
					rawrxd:Destroy()
				end)
				coru()
				local ree = Instance.new('ParticleEmitter',thing)
				ree.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.fromRGB(100,0,0)),ColorSequenceKeypoint.new(1,Color3.fromRGB(100,0,0))})
				ree.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.1),NumberSequenceKeypoint.new(1,0.1)})
				ree.Texture = 'rbxassetid://867743272'
				ree.Lifetime = NumberRange.new(0.4)
				ree.Rate = 50
				ree.LockedToPart = true
				ree.Speed = NumberRange.new(0, 2)  

				thing.Touched:connect(function(tou)
					if tou.Parent and tou.Parent:IsA('Tool') == false and tou.Parent.Parent:FindFirstChildOfClass('Humanoid') == nil and tou.Parent:FindFirstChildOfClass('Humanoid') == nil and tou.Name ~= "Blood" and tou.Parent.Name ~= "Projectile" and tou.Parent.Name ~= "big ass knife" and tou.Parent ~= player.Character and tou.Parent.ClassName ~= "Accessory" and tou.Parent.Name ~= "bitch ass knife" then
						local pos = Vector3.new(thing.Position.X,(tou.Position.Y+(tou.Size.Y/2))+0.02,thing.Position.Z)
						thing:Destroy()
						if tou.Name == "BloodPuddle" then
							local reee = tou.CFrame
							if tou.Transparency > -0.2 then
								tou.Transparency = tou.Transparency -0.1
							end
							if tou.Size.X < 10 then
								tou.Size = tou.Size+Vector3.new(0.1,0,0.1)
								tou.CFrame = reee
							end
						else
							local bloodlol = Instance.new('Part',workspace)
							bloodlol.Size=Vector3.new(1,0.2,1)
							bloodlol.Name = "BloodPuddle"
							bloodlol.Anchored = true
							bloodlol.CanCollide = false
							bloodlol.Material = Enum.Material.SmoothPlastic
							bloodlol.BrickColor = BrickColor.new('Maroon')
							local cyl = Instance.new('CylinderMesh',bloodlol)
							cyl.Scale = Vector3.new(1,0.1,1)
							bloodlol.CFrame = CFrame.new(pos)
							local coru=coroutine.wrap(function()
								while bloodlol.Parent ~= nil do
									if bloodlol.Transparency < 1 then
										bloodlol.Transparency = bloodlol.Transparency+0.05
									else
										bloodlol:Destroy()
									end
									wait(0.1)
								end
							end)
							coru()
						end
					end
				end)
				local coru = coroutine.wrap(function()
					wait(1)
					thing:Destroy()
				end)
				coru()
			end)
			reeee()
			wait()
		end
	end

	function killz(playa,hitz,kneef,explode,pool,head,charred,override)
		local soundy = false
		local heyy = hitz
		if hitz == "Right Arm" then
			local Limb = playa:FindFirstChild("Right Arm")
			local ters = playa:FindFirstChild('Torso')
			if Limb and ters then
				if ters:FindFirstChild('Right Shoulder') then ters["Right Shoulder"]:Destroy() end
				for i,v in pairs(Limb:GetChildren()) do
					if v:IsA('Weld') or v:IsA('Motor6D') or v:IsA('Rotate') then
						v:Destroy()
					end
				end
				Limb.CFrame = ters.CFrame * CFrame.new(1.5, 0, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "RightShoulder"
				Joint.Part0 = ters
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = ters
				if charred and zombiemode == false then 
					Limb.BrickColor = BrickColor.new('Black') 
					local fire = Instance.new('Fire',Limb)
					fire.Heat = 5
					fire.Size = 5
					game:GetService('Debris'):AddItem(fire,2)
					local coru=coroutine.wrap(function()
						wait(2)
						for i,v in pairs(Limb:GetChildren()) do
							if v:IsA('ParticleEmitter') then
								v:Destroy()
							end
						end
					end)
					coru()
				end
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
				if kneef then
					local coru = coroutine.wrap(function()
						local uno = Instance.new('Part',workspace)
						local dos = Instance.new('Part',workspace)
						uno.CFrame = playa:FindFirstChild(hitz).CFrame
						dos.CFrame = kneef["big ass knife"].CFrame
						local weld = Instance.new('Weld',kneef["big ass knife"])
						weld.Part0 = playa:FindFirstChild(hitz)
						weld.Part1 = kneef["big ass knife"]
						weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
						uno:Destroy()
						dos:Destroy()
						playa:FindFirstChild(hitz).Anchored = false
						for i, v in pairs(kneef:GetChildren()) do
							if v:IsA('BasePart') then
								v.Anchored = false
							end
						end
						if zombiemode == false or override then
							wait()
						end
						if kneef:FindFirstChild('Grab') and kneef.Grab:FindFirstChildOfClass('BodyVelocity') then
							kneef.Grab:FindFirstChildOfClass('BodyVelocity'):Destroy()
						end
						local bleedpart = Instance.new("Part", kneef)
						bleedpart.CanCollide = false
						bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
						bleedpart.CFrame = kneef["big ass knife"].CFrame
						bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
						bleedpart.Transparency = 1

						local bleedpartweld = Instance.new("Weld", kneef["big ass knife"])
						bleedpartweld.Part0 = kneef["big ass knife"]
						bleedpartweld.Part1 = bleedpart
						bleedpartweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)
						local coru = coroutine.wrap(function()
							bleed(bleedpart)
						end)
						coru()
						game:GetService('Debris'):AddItem(bleedpart,2)
					end)
					coru()
				end
			end 
		elseif hitz == "Left Arm" then
			local Limb = playa:FindFirstChild("Left Arm")
			local ters = playa:FindFirstChild('Torso')
			if Limb and ters then
				if ters:FindFirstChild('Left Shoulder') then ters["Left Shoulder"]:Destroy() end
				for i,v in pairs(Limb:GetChildren()) do
					if v:IsA('Weld') or v:IsA('Motor6D') or v:IsA('Rotate') then
						v:Destroy()
					end
				end
				Limb.CFrame = ters.CFrame * CFrame.new(-1.5, 0, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "LeftShoulder"
				Joint.Part0 = ters
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = ters
				if charred and zombiemode == false then 
					Limb.BrickColor = BrickColor.new('Black') 
					local fire = Instance.new('Fire',Limb)
					fire.Heat = 5
					fire.Size = 5
					game:GetService('Debris'):AddItem(fire,2)
					local coru=coroutine.wrap(function()
						wait(2)
						for i,v in pairs(Limb:GetChildren()) do
							if v:IsA('ParticleEmitter') then
								v:Destroy()
							end
						end
					end)
					coru()
				end

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.CanCollide = true
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = ters
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
				if kneef then
					local coru = coroutine.wrap(function()
						local uno = Instance.new('Part',workspace)
						local dos = Instance.new('Part',workspace)
						uno.CFrame = playa:FindFirstChild(hitz).CFrame
						dos.CFrame = kneef["big ass knife"].CFrame
						local weld = Instance.new('Weld',kneef["big ass knife"])
						weld.Part0 = playa:FindFirstChild(hitz)
						weld.Part1 = kneef["big ass knife"]
						weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
						uno:Destroy()
						dos:Destroy()
						playa:FindFirstChild(hitz).Anchored = false
						for i, v in pairs(kneef:GetChildren()) do
							if v:IsA('BasePart') then
								v.Anchored = false
							end
						end
						if zombiemode == false or override then
							wait()
						end
						if kneef:FindFirstChild('Grab') and kneef.Grab:FindFirstChildOfClass('BodyVelocity') then
							kneef.Grab:FindFirstChildOfClass('BodyVelocity'):Destroy()
						end
						local bleedpart = Instance.new("Part", kneef)
						bleedpart.CanCollide = false
						bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
						bleedpart.CFrame = kneef["big ass knife"].CFrame
						bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
						bleedpart.Transparency = 1

						local bleedpartweld = Instance.new("Weld", kneef["big ass knife"])
						bleedpartweld.Part0 = kneef["big ass knife"]
						bleedpartweld.Part1 = bleedpart
						bleedpartweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)
						local coru = coroutine.wrap(function()
							bleed(bleedpart)
						end)
						coru()
						game:GetService('Debris'):AddItem(bleedpart,2)
					end)
					coru()
				end
			end
		elseif hitz == "Right Leg" then
			local Limb = playa:FindFirstChild("Right Leg")
			local ters = playa:FindFirstChild('Torso')
			if Limb and ters then
				if ters:FindFirstChild('Right Hip') then ters["Right Hip"]:Destroy() end
				for i,v in pairs(Limb:GetChildren()) do
					if v:IsA('Weld') or v:IsA('Motor6D') or v:IsA('Rotate') then
						v:Destroy()
					end
				end
				Limb.CFrame = ters.CFrame * CFrame.new(0.5, -2, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "Right Hip"
				Joint.Part0 = ters
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = ters
				if charred and zombiemode == false then 
					Limb.BrickColor = BrickColor.new('Black') 
					local fire = Instance.new('Fire',Limb)
					fire.Heat = 5
					fire.Size = 5
					game:GetService('Debris'):AddItem(fire,2)
					local coru=coroutine.wrap(function()
						wait(2)
						for i,v in pairs(Limb:GetChildren()) do
							if v:IsA('ParticleEmitter') then
								v:Destroy()
							end
						end
					end)
					coru()
				end
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
				if kneef then
					local coru = coroutine.wrap(function()
						local uno = Instance.new('Part',workspace)
						local dos = Instance.new('Part',workspace)
						uno.CFrame = playa:FindFirstChild(hitz).CFrame
						dos.CFrame = kneef["big ass knife"].CFrame
						local weld = Instance.new('Weld',kneef["big ass knife"])
						weld.Part0 = playa:FindFirstChild(hitz)
						weld.Part1 = kneef["big ass knife"]
						weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
						uno:Destroy()
						dos:Destroy()
						playa:FindFirstChild(hitz).Anchored = false
						for i, v in pairs(kneef:GetChildren()) do
							if v:IsA('BasePart') then
								v.Anchored = false
							end
						end
						if zombiemode == false or override then
							wait()
						end
						if kneef:FindFirstChild('Grab') and kneef.Grab:FindFirstChildOfClass('BodyVelocity') then
							kneef.Grab:FindFirstChildOfClass('BodyVelocity'):Destroy()
						end
						local bleedpart = Instance.new("Part", kneef)
						bleedpart.CanCollide = false
						bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
						bleedpart.CFrame = kneef["big ass knife"].CFrame
						bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
						bleedpart.Transparency = 1

						local bleedpartweld = Instance.new("Weld", kneef["big ass knife"])
						bleedpartweld.Part0 = kneef["big ass knife"]
						bleedpartweld.Part1 = bleedpart
						bleedpartweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)
						local coru = coroutine.wrap(function()
							bleed(bleedpart)
						end)
						coru()
						game:GetService('Debris'):AddItem(bleedpart,2)
					end)
					coru()
				end
				if playa then
					table.insert(rekt,playa)
				end
			end
		elseif hitz == "Left Leg" then
			local Limb = playa:FindFirstChild("Left Leg")
			local ters = playa:FindFirstChild('Torso')
			if Limb and ters then
				if ters:FindFirstChild('Left Hip') then ters["Left Hip"]:Destroy() end
				for i,v in pairs(Limb:GetChildren()) do
					if v:IsA('Weld') or v:IsA('Motor6D') or v:IsA('Rotate') then
						v:Destroy()
					end
				end
				Limb.CFrame = ters.CFrame * CFrame.new(0.5, -2, 0)
				Limb.CFrame = ters.CFrame * CFrame.new(-0.5, -2, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "LeftHip"
				Joint.Part0 = ters
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = ters
				if charred and zombiemode == false then 
					Limb.BrickColor = BrickColor.new('Black') 
					local fire = Instance.new('Fire',Limb)
					fire.Heat = 5
					fire.Size = 5
					game:GetService('Debris'):AddItem(fire,2)
					local coru=coroutine.wrap(function()
						wait(2)
						for i,v in pairs(Limb:GetChildren()) do
							if v:IsA('ParticleEmitter') then
								v:Destroy()
							end
						end
					end)
					coru()
				end

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
				Limb.CanCollide = false
				if kneef then
					local coru = coroutine.wrap(function()
						local uno = Instance.new('Part',workspace)
						local dos = Instance.new('Part',workspace)
						uno.CFrame = playa:FindFirstChild(hitz).CFrame
						dos.CFrame = kneef["big ass knife"].CFrame
						local weld = Instance.new('Weld',kneef["big ass knife"])
						weld.Part0 = playa:FindFirstChild(hitz)
						weld.Part1 = kneef["big ass knife"]
						weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
						uno:Destroy()
						dos:Destroy()
						playa:FindFirstChild(hitz).Anchored = false
						for i, v in pairs(kneef:GetChildren()) do
							if v:IsA('BasePart') then
								v.Anchored = false
							end
						end
						if zombiemode == false or override then
							wait()
						end
						if kneef:FindFirstChild('Grab') and kneef.Grab:FindFirstChildOfClass('BodyVelocity') then
							kneef.Grab:FindFirstChildOfClass('BodyVelocity'):Destroy()
						end
						local bleedpart = Instance.new("Part", kneef)
						bleedpart.CanCollide = false
						bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
						bleedpart.CFrame = kneef["big ass knife"].CFrame
						bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
						bleedpart.Transparency = 1

						local bleedpartweld = Instance.new("Weld", kneef["big ass knife"])
						bleedpartweld.Part0 = kneef["big ass knife"]
						bleedpartweld.Part1 = bleedpart
						bleedpartweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)
						local coru = coroutine.wrap(function()
							bleed(bleedpart)
						end)
						coru()
						game:GetService('Debris'):AddItem(bleedpart,2)
					end)
					coru()
				end
				if playa then
					table.insert(rekt,playa)
				end
			end
		elseif playa then
			if finishnum ~= 1 then
				local coru=coroutine.wrap(function()
					player.Character.Head.Psycho.Playing = true
					wait(3)
					player.Character.Head.Psycho.Playing = false
				end)
				coru()
			end
			local playa2 = playa
			playa.Archivable = true
			local playa = playa:Clone()
			playa.Archivable = false
			playa2:Destroy()
			playa.Parent = workspace
			local Gibs = game.Workspace
			local Torso = playa.Torso
			local Head = playa:FindFirstChild("Head")
			local function Scan(ch)
				local e
				for e = 1,#ch do
					Scan(ch[e]:GetChildren())
					if (ch[e].ClassName == "Weld" and ch[e]:FindFirstChild('Part1') and ch[e].Part1.Name ~= 'Projectile') or ch[e].ClassName == "Motor6D" or ch[e].ClassName == "Rotate" or (ch[e]:IsA('BasePart') and ch[e].Size == Vector3.new(1, 1, 1)) then
						ch[e]:remove()
					end
				end
			end
			Scan(playa:GetChildren())
			if playa:FindFirstChild('HumanoidRootPart') and (zombiemode == false or override) then
				playa:FindFirstChild('HumanoidRootPart'):Destroy()
			end
			local hum2 = playa:FindFirstChildOfClass("Humanoid")
			if zombiemode == true and override == false then
				soundy = true
			end
			if string.sub(hum2.Parent.Name,string.len(hum2.Parent.Name)-8,string.len(hum2.Parent.Name)) ~= "'s Zombie" then
				override = true
			end
			if hum2 ~= nil then
				hum2.Name = "Humanoid2"
				hum2.Health = 0
				if zombiemode == false or override == true then
					table.insert(rekt,hum2.Parent)
				else
					local gyro = Instance.new('BodyGyro',Torso)
					hum2.PlatformStand = false
					for i,v in pairs(hum2.Parent.Torso:GetChildren()) do
						if v:IsA('BodyGyro') then v:Destroy() end
					end
					if playa:FindFirstChild('HumanoidRootPart') then
						hum2.Parent.HumanoidRootPart.CFrame = hum2.Parent.Torso.CFrame
						local weldcrucial = Instance.new('Weld',hum2.Parent.HumanoidRootPart)
						weldcrucial.Part0 = hum2.Parent.HumanoidRootPart
						weldcrucial.Part1 = hum2.Parent.Torso
					end
				end
			end
			local ch = playa:GetChildren()
			local i
			for i = 1,#ch do
				if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
					ch[i]:remove()
				end
			end

			if Head then
				local Neck = Instance.new("Weld")
				Neck.Name = "Neck"
				Neck.Part0 = Torso
				Neck.Part1 = Head
				if pool then
					local part = Instance.new('Part',Torso)
					part.Position = Vector3.new(0,10,0)
					part.Size = Vector3.new(0.2,0.2,0.2)
					part.Transparency = 1
					part.CanCollide = false
					local we = Instance.new('Weld',Torso)
					we.Part0 = Torso
					we.Part1 = part
					we.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)
					local coru=coroutine.wrap(function()
						bleed(part)
					end)
					coru()
				end
				if head == false or head == nil then
					Neck.C0 = CFrame.new(0, 1.5, 0)
				else
					Neck.C0 = CFrame.new(0, 1.5, 0.2)*CFrame.Angles(0.5, 0.25, 0.25)
					local bleedpart = Instance.new("Part", Torso)
					bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
					bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
					bleedpart.CanCollide = false
					bleedpart.Position = Head.Position + Vector3.new(0, 1, 0)
					bleedpart.Transparency = 1

					local bleedpartweld = Instance.new("Weld", Torso)
					bleedpartweld.Part0 = Torso
					bleedpartweld.Part1 = bleedpart
					bleedpartweld.C0 = CFrame.Angles(-1, 0, -0.35) * CFrame.new(0, 1, 0.8)
					local coru = coroutine.wrap(function()
						bleed(bleedpart)
					end)
					coru()
				end
				Neck.C1 = CFrame.new()
				Neck.Parent = Torso
			end
			local Limb = playa:FindFirstChild("Right Arm")
			if Limb then

				Limb.CFrame = Torso.CFrame * CFrame.new(1.5, 0, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "RightShoulder"
				Joint.Part0 = Torso
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
			end
			local Limb = playa:FindFirstChild("Left Arm")
			if Limb then

				Limb.CFrame = Torso.CFrame * CFrame.new(-1.5, 0, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "LeftShoulder"
				Joint.Part0 = Torso
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
			end
			local Limb = playa:FindFirstChild("Right Leg")
			if Limb then
				Limb.CanCollide = false
				Limb.CFrame = Torso.CFrame * CFrame.new(0.5, -2, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "RightHip"
				Joint.Part0 = Torso
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CanCollide = true
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
			end
			local Limb = playa:FindFirstChild("Left Leg")
			if Limb then
				Limb.CanCollide = false
				Limb.CFrame = Torso.CFrame * CFrame.new(-0.5, -2, 0)
				local Joint = Instance.new("Rotate")
				Joint.Name = "LeftHip"
				Joint.Part0 = Torso
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				if zombiemode == false or override then
					B.CanCollide = true
				end
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = playa
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
			end
        --[[
        local Bar = Instance.new("Part")
        Bar.TopSurface = 0
        Bar.BottomSurface = 0
        Bar.formFactor = "Symmetric"
        Bar.Size = Vector3.new(1, 1, 1)
        Bar.Transparency = 1
        Bar.CFrame = Torso.CFrame * CFrame.new(0, 0.5, 0)
        Bar.Parent = playa
        local Weld = Instance.new("Weld")
        Weld.Part0 = Torso
        Weld.Part1 = Bar
        Weld.C0 = CFrame.new(0, 0.5, 0)
        Weld.Parent = Torso
        --]]
			playa.Parent = Gibs
			if kneef and explode == nil then
				local coru = coroutine.wrap(function()
					if playa:FindFirstChild(hitz) then
						local uno = Instance.new('Part',workspace)
						local dos = Instance.new('Part',workspace)
						uno.CFrame = playa:FindFirstChild(hitz).CFrame
						dos.CFrame = kneef["big ass knife"].CFrame
						local weld = Instance.new('Weld',kneef["big ass knife"])
						weld.Part0 = playa:FindFirstChild(hitz)
						weld.Part1 = kneef["big ass knife"]
						weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
						uno:Destroy()
						dos:Destroy()
						playa:FindFirstChild(hitz).Anchored = false
						for i, v in pairs(kneef:GetChildren()) do
							if v:IsA('BasePart') then
								v.Anchored = false
							end
						end
						if explode == nil or explode == false then
							local bleedpart = Instance.new("Part", kneef)
							bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
							bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
							bleedpart.CanCollide = false
							bleedpart.Position = Head.Position + Vector3.new(0, 1, 0)
							bleedpart.Transparency = 1

							local bleedpartweld = Instance.new("Weld", kneef["big ass knife"])
							bleedpartweld.Part0 = kneef["big ass knife"]
							bleedpartweld.Part1 = bleedpart
							bleedpartweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)
							local coru = coroutine.wrap(function()
								bleed(bleedpart)
							end)
							coru()
						end
					end
					if zombiemode == false or override then
						wait()
					end
					if kneef:FindFirstChild('Grab') and kneef.Grab:FindFirstChildOfClass('BodyVelocity') then
						kneef.Grab:FindFirstChildOfClass('BodyVelocity'):Destroy()
					end
				end)
				coru()
			end
			if explode then
				local movevector = CFrame.new(explode.Position,Torso.Position).lookVector
				local repulse = Instance.new('BodyForce',Torso)
				repulse.Force = movevector*10000 + Vector3.new(0,5000,0)
				game.Debris:AddItem(repulse,0.05)
			end
			if charred and zombiemode == false then
				for i,v in pairs(playa:GetChildren()) do
					if v:IsA('BasePart') then
						v.BrickColor = BrickColor.Black()
						local fire = Instance.new('Fire',v)
						fire.Size = 5
						fire.Heat = 5
					elseif v:IsA('Accessory') then
						for a,c in pairs(v:GetChildren()) do
							if c:IsA('BasePart') then
								c.BrickColor = BrickColor.Black()
								local fire = Instance.new('Fire',v)
								fire.Size = 5
								fire.Heat = 5
								for o,p in pairs(c:GetChildren()) do
									if p:IsA("SpecialMesh") then
										p.TextureId = ""
									end
								end
							end
						end
					end
				end
			end
			if soundy then
				local sound = Instance.new('Sound',Head)
				sound.SoundId = 'rbxassetid://903640857'
				sound.Volume = 1
				sound:Play()
				sound.Ended:connect(function() 
					sound:Destroy()
					local ambient = Instance.new('Sound',Head)
					ambient.Volume = 0.25
					ambient.Looped = true
					ambient.SoundId = 'rbxassetid://903641031'
					ambient:Play()
				end)
			end
			if override then
				if (string.len(hum2.Parent.Name) < 9 or string.sub(hum2.Parent.Name,string.len(hum2.Parent.Name)-8,string.len(hum2.Parent.Name)) ~= "'s Zombie") and zombiemode == true and #zombies < 10 then
					local coru = coroutine.wrap(function()
						wait(4.5)
						hum2.Parent.Name = hum2.Parent.Name.."'s Zombie"
						hum2.HipHeight = 0.2
						wait(0.5)
						killz(hum2.Parent,"Head",nil,nil,false,false,false,false)
					end)
					coru()
				else
					game:GetService('Debris'):AddItem(playa, 12)
				end
			else
				hum2.Health = 0
				table.insert(zombies,playa)
				local attack = Instance.new('Sound',Head)
				attack.SoundId = 'rbxassetid://903641424'
				attack.Volume = 2
				for i,v in pairs(playa:GetChildren()) do
					if v:IsA('BasePart') and v:FindFirstChildOfClass('TouchTransmitter') == nil then
						v.Touched:connect(function(hit)
							if hit.Parent and hit.Parent:FindFirstChildOfClass('Humanoid') then
								local found = false
								if hit.Parent == player.Character then
									found = true
								end
								for a,c in pairs(zombies) do
									if c == hit.Parent then
										found = true
									end
								end
								if found == false and hit.Parent:FindFirstChildOfClass('Humanoid').Health > 0 then
									attack:Play()
									if hit.Parent:FindFirstChildOfClass('Humanoid').Health - 2 <= 0 then
										hit.Parent:FindFirstChildOfClass('Humanoid').Health = 0
										wait()
										killz(hit.Parent,"Head")
									else
										hit.Parent:FindFirstChildOfClass('Humanoid'):TakeDamage(2)
									end
								end
							end
						end)
					end
				end
				local coru = coroutine.wrap(function()
					wait(2)
					for i,v in pairs(playa:GetChildren()) do
						if v:IsA('BasePart') then
							for a,c in pairs(v:GetChildren()) do
								if c:IsA('Fire') or c:IsA('ParticleEmitter') then
									c:Destroy()
								end
							end
						elseif v:IsA('Accessory') then
							for a,c in pairs(v:GetChildren()) do
								if c:IsA('BasePart') then
									for b,d in pairs(c:GetChildren()) do
										if d:IsA('Fire') or d:IsA('ParticleEmitter') then
											d:Destroy()
										end
									end
								end
							end
						end
					end
				end)
				coru()
			end
		end 
	end

	mouse.KeyDown:connect(function(key)
		if key == "t" and mouse.Target then
			local hum = mouse.Target.Parent:FindFirstChildOfClass('Humanoid')
			if hum == nil then hum = mouse.Target.Parent.Parent:FindFirstChildOfClass('Humanoid') end
			if curpoint == nil then
				if hum and hum.Parent:FindFirstChild('Head') then
					curpart = hum.Parent.Head
				else
					curpart = nil
					curpoint = mouse.Hit.p
				end
				if player.PlayerGui:FindFirstChild('Notification') then player.PlayerGui.Notification:Destroy() end
				notify("ZOMBIE TARGET SET",false)
			else
				curpart = nil
				curpoint = nil
				if player.PlayerGui:FindFirstChild('Notification') then player.PlayerGui.Notification:Destroy() end
				notify("ZOMBIE TARGET REMOVED",false)
			end
		elseif key == "y" then
			for o,p in pairs(zombies) do
				local coru = coroutine.wrap(function()
					if p:FindFirstChild('Torso') then
						killz(p,"Head",nil,nil,false,false,false,true)
					else
						table.remove(zombies,o)
					end
				end)
				coru()
				wait()
			end
			for i,v in pairs(zombies) do
				table.remove(zombies,i)
			end
			if player.PlayerGui:FindFirstChild('Notification') then player.PlayerGui.Notification:Destroy() end
			notify("ZOMBIES TERMINATED",false)
		end
	end)

	function nub()
		local me = player.Character
		local point = me.HumanoidRootPart
		local playergui = player.PlayerGui
		local rightshoulderz = me.Torso["Right Shoulder"]:Clone()
		local leftshoulderz = me.Torso["Left Shoulder"]:Clone()
		local torsojoint = me.HumanoidRootPart["RootJoint"]:Clone()
		local lefthipz = me.Torso["Left Hip"]:Clone()
		local righthipz = me.Torso["Right Hip"]:Clone()
		local mode = "kill"
		local lerpz = false
		local active = false
		local acting = false
		local hit = false
		local canClick = true
		local stabbing = false
		local grabbing = false
		local finishing = false
		local kyssing = false
		local canbackgroundmusic = true
		local cancolorfilter = true
		local spinboolean = false
		local grabbed = nil
		local doing = false
		local rightshoulder = nil
		local leftshoulder = nil
		local headweld = nil
		local usable = true
		finishnum = 1

		function notify(msg,forever)
			local doit = coroutine.wrap(function()
				local gui = Instance.new('ScreenGui',playergui)
				gui.Name = "Notification"
				local frame = Instance.new('Frame',gui)
				frame.Position = UDim2.new(0,0,0,0)
				frame.Size = UDim2.new(1,0,0.2,0)
				frame.BackgroundTransparency = 1
				local txt = Instance.new('TextLabel',frame)
				txt.TextColor3 = Color3.new(255,255,255)
				txt.TextStrokeColor3 = Color3.new(0, 0, 0)
				txt.TextStrokeTransparency = 0
				txt.BackgroundTransparency = 1
				txt.Text = ""
				txt.Size = UDim2.new(1,0,0.3,0)
				txt.Position = UDim2.new(0,0,0.4,0)
				txt.TextScaled = true
				txt.Font = "Code"
				txt.TextXAlignment = "Center"
				local tap = Instance.new("Sound")
				tap.Parent = gui
				tap.SoundId = "rbxassetid://147982968"
				tap.TimePosition = 0.1
				local str = msg
				local len = string.len(str)
				for i=1,len do
					txt.Text = string.sub(str,1,i)
					pitche = math.random(20, 40)/10
					tap.PlaybackSpeed = pitche
					tap:Play()
					wait(0.01)
				end
				if forever == false then
					wait(1)
					while txt.TextTransparency < 1 do
						txt.TextTransparency = txt.TextTransparency + 0.1
						txt.TextStrokeTransparency = txt.TextStrokeTransparency + 0.1
						wait(0.001)
					end
					gui:Destroy()
				end
			end)
			doit()
		end

		wait(0.5)
		notify("Loaded Now Go Rekt Da Kids",true)
		local laugh = Instance.new('Sound',me.Head)
		laugh.SoundId = 'rbxassetid://378827985'
		laugh.Name = "Psycho"
		laugh.Volume = 5
		-- 1 - bitch ass knife
		local obj1 = Instance.new("Model")
		obj1.Name = "bitch ass knife"
		obj1.Parent = game.Workspace

		-- 2 - Grab
		local obj2 = Instance.new("Part")
		obj2.CFrame = CFrame.new(Vector3.new(20.4525032, 6.14501333, -134.399979)) * CFrame.Angles(-3.1415927410126, 0, -3.1415927410126)
		obj2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj2.Material = Enum.Material.Concrete
		obj2.Size = Vector3.new(1, 0.25, 0.25)
		obj2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj2.Anchored = true
		obj2.BrickColor = BrickColor.new("Black")
		obj2.Friction = 0.30000001192093
		obj2.Shape = Enum.PartType.Cylinder
		obj2.Name = "Grab"
		obj2.Parent = obj1

		-- 3 - handletopcap
		local obj3 = Instance.new("Part")
		obj3.CFrame = CFrame.new(Vector3.new(19.9725456, 6.14502859, -134.399933)) * CFrame.Angles(0, 1.5707963705063, 0)
		obj3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj3.Material = Enum.Material.Concrete
		obj3.Size = Vector3.new(0.349999994, 0.349999994, 0.349999994)
		obj3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj3.Anchored = true
		obj3.BrickColor = BrickColor.new("Black")
		obj3.Friction = 0.30000001192093
		obj3.Shape = Enum.PartType.Ball
		obj3.Name = "handletopcap"
		obj3.Parent = obj1

		-- 4 - handlebottomcap
		local obj4 = Instance.new("Part")
		obj4.CFrame = CFrame.new(Vector3.new(20.9725285, 6.14502859, -134.399918)) * CFrame.Angles(0, 1.5707963705063, 0)
		obj4.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj4.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj4.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj4.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj4.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj4.Material = Enum.Material.Concrete
		obj4.Size = Vector3.new(0.25, 0.25, 0.25)
		obj4.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj4.Anchored = true
		obj4.BrickColor = BrickColor.new("Black")
		obj4.Friction = 0.30000001192093
		obj4.Shape = Enum.PartType.Ball
		obj4.Name = "handlebottomcap"
		obj4.Parent = obj1

		-- 5 - handleguardmid
		local obj5 = Instance.new("Part")
		obj5.CFrame = CFrame.new(Vector3.new(19.9474983, 6.14502859, -134.399918)) * CFrame.Angles(0, 1.5707963705063, 0)
		obj5.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj5.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj5.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj5.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj5.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj5.Material = Enum.Material.Concrete
		obj5.Size = Vector3.new(0.349999994, 0.349999994, 0.100000001)
		obj5.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj5.Anchored = true
		obj5.BrickColor = BrickColor.new("Black")
		obj5.Friction = 0.30000001192093
		obj5.Shape = Enum.PartType.Block
		obj5.Name = "handleguardmid"
		obj5.Parent = obj1

		-- 6 - handleguardcap1
		local obj6 = Instance.new("Part")
		obj6.CFrame = CFrame.new(Vector3.new(19.9474983, 6.32502794, -134.399918)) * CFrame.Angles(-3.1415927410126, 0, -3.1415927410126)
		obj6.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj6.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj6.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj6.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj6.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj6.Material = Enum.Material.Concrete
		obj6.Size = Vector3.new(0.100000001, 0.349999994, 0.349999994)
		obj6.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj6.Anchored = true
		obj6.BrickColor = BrickColor.new("Black")
		obj6.Friction = 0.30000001192093
		obj6.Shape = Enum.PartType.Cylinder
		obj6.Name = "handleguardcap1"
		obj6.Parent = obj1

		-- 7 - handleguardcap2
		local obj7 = Instance.new("Part")
		obj7.CFrame = CFrame.new(Vector3.new(19.9474983, 5.97502899, -134.399918)) * CFrame.Angles(-3.1415927410126, 0, -3.1415927410126)
		obj7.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj7.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj7.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj7.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj7.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj7.Material = Enum.Material.Concrete
		obj7.Size = Vector3.new(0.100000009, 0.349999994, 0.349999994)
		obj7.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj7.Anchored = true
		obj7.BrickColor = BrickColor.new("Black")
		obj7.Friction = 0.30000001192093
		obj7.Shape = Enum.PartType.Cylinder
		obj7.Name = "handleguardcap2"
		obj7.Parent = obj1

		-- 8 - big ass knife
		local obj8 = Instance.new("Part")
		obj8.CFrame = CFrame.new(Vector3.new(18.4375095, 6.14502859, -134.401321)) * CFrame.Angles(0, 1.5707963705063, 0)
		obj8.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj8.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj8.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj8.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj8.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj8.Material = Enum.Material.Metal
		obj8.Size = Vector3.new(0.0500000007, 0.280000001, 0.839999795)
		obj8.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj8.Anchored = true
		obj8.BrickColor = BrickColor.new("Lily white")
		obj8.Friction = 0.30000001192093
		obj8.Shape = Enum.PartType.Block
		obj8.Name = "big ass knife"
		obj8.Parent = obj1

		-- 9 - Mesh
		local obj9 = Instance.new("BlockMesh")
		obj9.Scale = Vector3.new(0.5, 1, 1)
		obj9.Parent = obj8

		-- 10 - big ass knife
		local obj10 = Instance.new("Part")
		obj10.CFrame = CFrame.new(Vector3.new(19.7425137, 6.14502859, -134.401321)) * CFrame.Angles(0, 1.5707963705063, 0)
		obj10.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj10.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj10.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj10.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj10.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj10.Material = Enum.Material.Metal
		obj10.Size = Vector3.new(0.0500000007, 0.280000001, 0.289999962)
		obj10.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj10.Anchored = true
		obj10.BrickColor = BrickColor.new("Lily white")
		obj10.Friction = 0.30000001192093
		obj10.Shape = Enum.PartType.Block
		obj10.Name = "big ass knife"
		obj10.Parent = obj1
		local knife = obj10

		-- 11 - Mesh
		local obj11 = Instance.new("BlockMesh")
		obj11.Scale = Vector3.new(0.5, 1, 1)
		obj11.Parent = obj10

		-- 12 - big ass knife
		local obj12 = Instance.new("Part")
		obj12.CFrame = CFrame.new(Vector3.new(19.1075306, 6.08502865, -134.401321)) * CFrame.Angles(0, 1.5707963705063, 0)
		obj12.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj12.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj12.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj12.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj12.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj12.Material = Enum.Material.Metal
		obj12.Size = Vector3.new(0.0500000007, 0.159999996, 0.979999959)
		obj12.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj12.Anchored = true
		obj12.BrickColor = BrickColor.new("Lily white")
		obj12.Friction = 0.30000001192093
		obj12.Shape = Enum.PartType.Block
		obj12.Name = "big ass knife"
		obj12.Parent = obj1

		-- 13 - Mesh
		local obj13 = Instance.new("BlockMesh")
		obj13.Scale = Vector3.new(0.5, 1, 1)
		obj13.Parent = obj12

		-- 14 - serration
		local obj14 = Instance.new("WedgePart")
		obj14.CFrame = CFrame.new(Vector3.new(19.4963322, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj14.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj14.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj14.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj14.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj14.Material = Enum.Material.Metal
		obj14.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj14.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj14.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj14.Anchored = true
		obj14.BrickColor = BrickColor.new("Lily white")
		obj14.Friction = 0.30000001192093
		obj14.Name = "serration"
		obj14.Parent = obj1

		-- 15 - Mesh
		local obj15 = Instance.new("BlockMesh")
		obj15.Scale = Vector3.new(0.5, 1, 1)
		obj15.Parent = obj14

		-- 16 - serration
		local obj16 = Instance.new("WedgePart")
		obj16.CFrame = CFrame.new(Vector3.new(19.2763138, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj16.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj16.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj16.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj16.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj16.Material = Enum.Material.Metal
		obj16.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj16.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj16.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj16.Anchored = true
		obj16.BrickColor = BrickColor.new("Lily white")
		obj16.Friction = 0.30000001192093
		obj16.Name = "serration"
		obj16.Parent = obj1

		-- 17 - Mesh
		local obj17 = Instance.new("BlockMesh")
		obj17.Scale = Vector3.new(0.5, 1, 1)
		obj17.Parent = obj16

		-- 18 - serration
		local obj18 = Instance.new("WedgePart")
		obj18.CFrame = CFrame.new(Vector3.new(19.3863068, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj18.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj18.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj18.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj18.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj18.Material = Enum.Material.Metal
		obj18.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj18.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj18.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj18.Anchored = true
		obj18.BrickColor = BrickColor.new("Lily white")
		obj18.Friction = 0.30000001192093
		obj18.Name = "serration"
		obj18.Parent = obj1

		-- 19 - Mesh
		local obj19 = Instance.new("BlockMesh")
		obj19.Scale = Vector3.new(0.5, 1, 1)
		obj19.Parent = obj18

		-- 20 - serration
		local obj20 = Instance.new("WedgePart")
		obj20.CFrame = CFrame.new(Vector3.new(19.5963173, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj20.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj20.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj20.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj20.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj20.Material = Enum.Material.Metal
		obj20.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj20.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj20.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj20.Anchored = true
		obj20.BrickColor = BrickColor.new("Lily white")
		obj20.Friction = 0.30000001192093
		obj20.Name = "serration"
		obj20.Parent = obj1

		-- 21 - Mesh
		local obj21 = Instance.new("BlockMesh")
		obj21.Scale = Vector3.new(0.5, 1, 1)
		obj21.Parent = obj20

		-- 22 - serration
		local obj22 = Instance.new("WedgePart")
		obj22.CFrame = CFrame.new(Vector3.new(19.1663074, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj22.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj22.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj22.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj22.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj22.Material = Enum.Material.Metal
		obj22.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj22.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj22.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj22.Anchored = true
		obj22.BrickColor = BrickColor.new("Lily white")
		obj22.Friction = 0.30000001192093
		obj22.Name = "serration"
		obj22.Parent = obj1

		-- 23 - Mesh
		local obj23 = Instance.new("BlockMesh")
		obj23.Scale = Vector3.new(0.5, 1, 1)
		obj23.Parent = obj22

		-- 24 - serration
		local obj24 = Instance.new("WedgePart")
		obj24.CFrame = CFrame.new(Vector3.new(18.9663048, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj24.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj24.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj24.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj24.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj24.Material = Enum.Material.Metal
		obj24.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj24.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj24.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj24.Anchored = true
		obj24.BrickColor = BrickColor.new("Lily white")
		obj24.Friction = 0.30000001192093
		obj24.Name = "serration"
		obj24.Parent = obj1

		-- 25 - Mesh
		local obj25 = Instance.new("BlockMesh")
		obj25.Scale = Vector3.new(0.5, 1, 1)
		obj25.Parent = obj24

		-- 26 - serration
		local obj26 = Instance.new("WedgePart")
		obj26.CFrame = CFrame.new(Vector3.new(18.8562984, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj26.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj26.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj26.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj26.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj26.Material = Enum.Material.Metal
		obj26.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj26.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj26.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj26.Anchored = true
		obj26.BrickColor = BrickColor.new("Lily white")
		obj26.Friction = 0.30000001192093
		obj26.Name = "serration"
		obj26.Parent = obj1

		-- 27 - Mesh
		local obj27 = Instance.new("BlockMesh")
		obj27.Scale = Vector3.new(0.5, 1, 1)
		obj27.Parent = obj26

		-- 28 - serration
		local obj28 = Instance.new("WedgePart")
		obj28.CFrame = CFrame.new(Vector3.new(19.0663071, 6.15381575, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj28.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj28.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj28.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj28.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj28.Material = Enum.Material.Metal
		obj28.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj28.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj28.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj28.Anchored = true
		obj28.BrickColor = BrickColor.new("Lily white")
		obj28.Friction = 0.30000001192093
		obj28.Name = "serration"
		obj28.Parent = obj1

		-- 29 - Mesh
		local obj29 = Instance.new("BlockMesh")
		obj29.Scale = Vector3.new(0.5, 1, 1)
		obj29.Parent = obj28

		-- 30 - knifetip1
		local obj30 = Instance.new("WedgePart")
		obj30.CFrame = CFrame.new(Vector3.new(18.0163059, 6.14381599, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj30.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj30.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj30.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj30.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj30.Material = Enum.Material.Metal
		obj30.Size = Vector3.new(0.0500000007, 0.200000003, 0.200000003)
		obj30.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj30.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj30.Anchored = true
		obj30.BrickColor = BrickColor.new("Lily white")
		obj30.Friction = 0.30000001192093
		obj30.Name = "knifetip1"
		obj30.Parent = obj1

		-- 31 - Mesh
		local obj31 = Instance.new("BlockMesh")
		obj31.Scale = Vector3.new(0.5, 1, 1)
		obj31.Parent = obj30

		-- 32 - redstuff
		local obj32 = Instance.new("Part")
		obj32.CFrame = CFrame.new(Vector3.new(19.9470005, 5.9749999, -134.399994)) * CFrame.Angles(-0, 0, -0)
		obj32.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj32.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj32.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj32.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj32.Material = Enum.Material.SmoothPlastic
		obj32.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj32.Size = Vector3.new(0.0500000007, 0.360000014, 0.360000014)
		obj32.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj32.BrickColor = BrickColor.new("Institutional white")
		obj32.Friction = 0.30000001192093
		obj32.Shape = Enum.PartType.Cylinder
		obj32.Name = "redstuff"
		obj32.Anchored = true
		obj32.Parent = obj1


		-- 33 - redstuff
		local obj33 = Instance.new("Part")
		obj33.CFrame = CFrame.new(Vector3.new(18.9800053, 6.1400156, -134.404984)) * CFrame.Angles(-0, 0, -0)
		obj33.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj33.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj33.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj33.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj33.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj33.Material = Enum.Material.SmoothPlastic
		obj33.Size = Vector3.new(1.81999993, 0.100000001, 0.0500000007)
		obj33.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj33.BrickColor = BrickColor.new("Institutional white")
		obj33.Friction = 0.30000001192093
		obj33.Shape = Enum.PartType.Block
		obj33.Name = "redstuff"
		obj33.Anchored = true
		obj33.Parent = obj1

		-- 34 - redstuff
		local obj34 = Instance.new("Part")
		obj34.CFrame = CFrame.new(Vector3.new(19.9470005, 6.32499981, -134.399994)) * CFrame.Angles(-0, 0, -0)
		obj34.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj34.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj34.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj34.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj34.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj34.Size = Vector3.new(0.0500000007, 0.360000014, 0.360000014)
		obj34.Material = Enum.Material.SmoothPlastic
		obj34.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj34.BrickColor = BrickColor.new("Institutional white")
		obj34.Friction = 0.30000001192093
		obj34.Shape = Enum.PartType.Cylinder
		obj34.Name = "redstuff"
		obj34.Anchored = true
		obj34.Parent = obj1

		-- 35 - redstuff
		local obj35 = Instance.new("Part")
		obj35.CFrame = CFrame.new(Vector3.new(19.8830166, 6.14501476, -134.399963)) * CFrame.Angles(-0, 0, -0)
		obj35.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj35.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj35.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj35.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj35.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj35.Size = Vector3.new(0.0500000007, 0.319999993, 0.319999993)
		obj35.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj35.BrickColor = BrickColor.new("Institutional white")
		obj35.Friction = 0.30000001192093
		obj35.Shape = Enum.PartType.Cylinder
		obj35.Material = Enum.Material.SmoothPlastic
		obj35.Name = "redstuff"
		obj35.Anchored = true
		obj35.Parent = obj1

		-- 36 - redstuff
		local obj36 = Instance.new("Part")
		obj36.CFrame = CFrame.new(Vector3.new(20.9430103, 6.14501476, -134.399963)) * CFrame.Angles(-0, 0, -0)
		obj36.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj36.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj36.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj36.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj36.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj36.Material = Enum.Material.SmoothPlastic
		obj36.Size = Vector3.new(0.0500000007, 0.25999999, 0.25999999)
		obj36.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj36.BrickColor = BrickColor.new("Institutional white")
		obj36.Friction = 0.30000001192093
		obj36.Shape = Enum.PartType.Cylinder
		obj36.Name = "redstuff"
		obj36.Anchored = true
		obj36.Parent = obj1

		-- 37 - redstuff
		local obj37 = Instance.new("WedgePart")
		obj37.CFrame = CFrame.new(Vector3.new(18.066288, 6.14381599, -134.400375)) * CFrame.Angles(1.5707963705063, -0.78539824485779, -1.5707963705063)
		obj37.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj37.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj37.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj37.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj37.Material = Enum.Material.SmoothPlastic
		obj37.Size = Vector3.new(0.0500000007, 0.0700000003, 0.0700000003)
		obj37.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj37.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj37.Anchored = true
		obj37.BrickColor = BrickColor.new("Institutional white")
		obj37.Friction = 0.30000001192093
		obj37.Name = "redstuff"
		obj37.Anchored = true
		obj37.Parent = obj1

		-- 38 - redstuff
		local obj38 = Instance.new("Part")
		obj38.CFrame = CFrame.new(Vector3.new(20.1230125, 6.14501476, -134.399979)) * CFrame.Angles(-0, 0, -0)
		obj38.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		obj38.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		obj38.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		obj38.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		obj38.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		obj38.Material = Enum.Material.SmoothPlastic
		obj38.Size = Vector3.new(0.0500000007, 0.25999999, 0.25999999)
		obj38.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		obj38.BrickColor = BrickColor.new("Institutional white")
		obj38.Friction = 0.30000001192093
		obj38.Shape = Enum.PartType.Cylinder
		obj38.Name = "redstuff"
		obj38.Anchored = true
		obj38.Parent = obj1

		local audio = Instance.new('Sound',knife)
		audio.Volume = 2

		local audio2 = Instance.new('Sound',knife)
		audio2.Volume = 2

		local holdpart = Instance.new("Part")
		holdpart.Parent = me
		holdpart.Size = Vector3.new(0.4, 0.4, 0.2)
		holdpart.Position = me.Head.Position + Vector3.new(0, 1, 0)
		holdpart.BrickColor = BrickColor.new("Burnt Sienna")

		local previous = nil
		for i,v in pairs(obj1:GetChildren()) do
			if v:IsA('BasePart') then
				if previous then
					local weld = Instance.new('Weld',v)
					weld.Part0 = v
					weld.Part1 = previous
					weld.C0 = v.CFrame:inverse() * previous.CFrame
					previous.Anchored = false
					previous.CanCollide = false
					local vee = v
					weld.AncestryChanged:connect(function(mez,par)
						wait()
						weld.Parent = vee
					end)
				end
				previous = v
			end
		end
		previous.Anchored = false
		previous.CanCollide = false

		local holdpartweld = Instance.new("Weld", me.Torso)
		holdpartweld.Part0 = me.Torso
		holdpartweld.Part1 = holdpart
		holdpartweld.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(-1, -0.8, 0.15)

		holdpartweld.AncestryChanged:connect(function(mez,par)
			if par ~= me.Torso then
				wait()
				holdpartweld.Parent = me.Torso
			end
		end)

		local knifeweld = Instance.new('Weld',me.Torso)
		knifeweld.Part0 = me.Torso
		knifeweld.Part1 = obj2
		knifeweld.C1 = CFrame.Angles(0,math.rad(90),0) * CFrame.new(1, 0.8, 0.55)
		knifeweld.AncestryChanged:connect(function(mez,par)
			if par ~= me.Torso then
				wait()
				knifeweld.Parent = me.Torso
			end
		end)
		local ScreenGui = Instance.new("ScreenGui")
		local CustomizeGui = Instance.new("Frame")
		local Customize = Instance.new("TextLabel")
		local ClosestColor = Instance.new("TextLabel")
		local Line = Instance.new("TextLabel")
		local Color = Instance.new("ImageLabel")
		local Close = Instance.new("TextButton")
		local RedHue = Instance.new("TextLabel")
		local GreenHue = Instance.new("TextLabel")
		local RedInput = Instance.new("TextBox")
		local BlueHue = Instance.new("TextLabel")
		local GreenInput = Instance.new("TextBox")
		local TransInput = Instance.new("TextBox")
		local BlueInput = Instance.new("TextBox")
		local Message = Instance.new("TextLabel")
		local Message2 = Instance.new("TextLabel")
		local TrailTransparency = Instance.new("TextLabel")
		local TrailInput = Instance.new("TextBox")
		local MusicOption = Instance.new("TextButton")
		local ScreenOption = Instance.new("TextButton")
		local ScreenOptionTxt = Instance.new("TextLabel")
		local MusicOptionTxt = Instance.new("TextLabel")

		-- Properties

		ScreenGui.Parent = playergui

		CustomizeGui.Name = "CustomizeGui"
		CustomizeGui.Parent = ScreenGui
		CustomizeGui.BackgroundColor3 = Color3.new(0.294118, 0.294118, 0.294118)
		CustomizeGui.BackgroundTransparency = 0.5
		CustomizeGui.BorderColor3 = Color3.new(0, 0, 0)
		CustomizeGui.BorderSizePixel = 2
		CustomizeGui.Position = UDim2.new(0, 0, 0.5, 0)
		CustomizeGui.Size = UDim2.new(0.449999988, 0, 0.449999988, 0)

		Customize.Name = "Customize"
		Customize.Parent = CustomizeGui
		Customize.BackgroundColor3 = Color3.new(0.294118, 0.294118, 0.294118)
		Customize.BackgroundTransparency = 0.75
		Customize.BorderSizePixel = 0
		Customize.Size = UDim2.new(1, 0, 0.200000003, 0)
		Customize.FontSize = Enum.FontSize.Size28
		Customize.Text = "ACCENT COLOR CUSTOMIZATION"
		Customize.TextColor3 = Color3.new(1, 1, 1)
		Customize.TextScaled = true
		Customize.TextSize = 25
		Customize.TextStrokeTransparency = 0.5
		Customize.TextWrapped = true

		ClosestColor.Name = "ClosestColor"
		ClosestColor.Parent = CustomizeGui
		ClosestColor.BackgroundColor3 = Color3.new(1, 1, 1)
		ClosestColor.BackgroundTransparency = 1
		ClosestColor.Position = UDim2.new(0, 0, 0.850000024, 0)
		ClosestColor.Size = UDim2.new(1, 0, 0.150000006, 0)
		ClosestColor.Font = Enum.Font.SourceSansLight
		ClosestColor.FontSize = Enum.FontSize.Size32
		ClosestColor.Text = "Your color is closest to Institutional White"
		ClosestColor.TextColor3 = Color3.new(1, 1, 1)
		ClosestColor.TextSize = 30
		ClosestColor.TextStrokeTransparency = 0.5

		Line.Name = "Line"
		Line.Parent = CustomizeGui
		Line.BackgroundColor3 = Color3.new(0.137255, 0.137255, 0.137255)
		Line.BackgroundTransparency = 0.5
		Line.BorderColor3 = Color3.new(0, 0, 0)
		Line.BorderSizePixel = 0
		Line.Position = UDim2.new(0, 0, 0.200000003, 0)
		Line.Size = UDim2.new(1, 0, 0.0299999993, 0)
		Line.Font = Enum.Font.SourceSans
		Line.FontSize = Enum.FontSize.Size14
		Line.Text = " "
		Line.TextSize = 14

		Color.Name = "Color"
		Color.Parent = CustomizeGui
		Color.BackgroundColor3 = Color3.new(1, 1, 1)
		Color.BorderSizePixel = 0
		Color.Position = UDim2.new(0.699999988, 0, 0.419999987, 0)
		Color.Size = UDim2.new(0.300000012, 0, 0.300000012, 0)
		Color.SizeConstraint = Enum.SizeConstraint.RelativeYY

		MusicOption.Parent = CustomizeGui
		MusicOption.Name = "MusicOption"
		MusicOption.BackgroundColor3 = Color3.new(0, 1, 0)
		MusicOption.BorderSizePixel = 1
		MusicOption.Position = UDim2.new(0.01, 0, -0.12, 0)
		MusicOption.Size = UDim2.new(0.05, 0, 0.1, 0)
		MusicOption.Text = ""
		MusicOption.BackgroundTransparency = 0.5

		ScreenOption.Parent = CustomizeGui
		ScreenOption.Name = "ScreenOption"
		ScreenOption.BackgroundColor3 = Color3.new(0, 1, 0)
		ScreenOption.BorderSizePixel = 1
		ScreenOption.Position = UDim2.new(0.01, 0, -0.23, 0)
		ScreenOption.Size = UDim2.new(0.05, 0, 0.1, 0)
		ScreenOption.Text = ""
		ScreenOption.BackgroundTransparency = 0.5

		ScreenOptionTxt.Name = "ScreenOptionTxt"
		ScreenOptionTxt.Parent = CustomizeGui
		ScreenOptionTxt.BackgroundColor3 = Color3.new(1, 1, 1)
		ScreenOptionTxt.BackgroundTransparency = 1
		ScreenOptionTxt.Position = UDim2.new(0.07, 0, -0.23, 0)
		ScreenOptionTxt.Size = UDim2.new(1, 0, 0.07, 0)
		ScreenOptionTxt.Font = Enum.Font.SourceSans
		ScreenOptionTxt.FontSize = Enum.FontSize.Size24
		ScreenOptionTxt.Text = "Psychopath Red Filter"
		ScreenOptionTxt.TextColor3 = Color3.new(1, 1, 1)
		ScreenOptionTxt.TextScaled = true
		ScreenOptionTxt.TextSize = 20
		ScreenOptionTxt.TextStrokeColor3 = Color3.new(0, 0, 0)
		ScreenOptionTxt.TextStrokeTransparency = 0.5
		ScreenOptionTxt.TextWrapped = true
		ScreenOptionTxt.TextXAlignment = "Left"

		MusicOptionTxt.Name = "MusicOptionTxt"
		MusicOptionTxt.Parent = CustomizeGui
		MusicOptionTxt.BackgroundColor3 = Color3.new(1, 1, 1)
		MusicOptionTxt.BackgroundTransparency = 1
		MusicOptionTxt.Position = UDim2.new(0.07, 0, -0.12, 0)
		MusicOptionTxt.Size = UDim2.new(1, 0, 0.07, 0)
		MusicOptionTxt.Font = Enum.Font.SourceSans
		MusicOptionTxt.FontSize = Enum.FontSize.Size24
		MusicOptionTxt.Text = "Psychopath Background Music"
		MusicOptionTxt.TextColor3 = Color3.new(1, 1, 1)
		MusicOptionTxt.TextScaled = true
		MusicOptionTxt.TextSize = 20
		MusicOptionTxt.TextStrokeColor3 = Color3.new(0, 0, 0)
		MusicOptionTxt.TextStrokeTransparency = 0.5
		MusicOptionTxt.TextWrapped = true
		MusicOptionTxt.TextXAlignment = "Left"

		Close.Name = "Close"
		Close.Parent = CustomizeGui
		Close.BackgroundColor3 = Color3.new(0.294118, 0.294118, 0.294118)
		Close.BackgroundTransparency = 0.5
		Close.BorderColor3 = Color3.new(0, 0, 0)
		Close.BorderSizePixel = 2
		Close.Position = UDim2.new(1.005, 0, 0, 0)
		Close.Size = UDim2.new(0.100000001, 0, 0.2, 0)
		Close.Font = Enum.Font.SourceSans
		Close.FontSize = Enum.FontSize.Size14
		Close.Text = "X"
		Close.TextColor3 = Color3.new(1, 1, 1)
		Close.TextScaled = true
		Close.TextSize = 14
		Close.TextStrokeTransparency = 0
		Close.TextWrapped = true

		RedHue.Name = "RedHue"
		RedHue.Parent = CustomizeGui
		RedHue.BackgroundColor3 = Color3.new(1, 1, 1)
		RedHue.BackgroundTransparency = 1
		RedHue.Position = UDim2.new(0.100000001, 0, 0.400000006, 0)
		RedHue.Size = UDim2.new(0.300000012, 0, 0.100000001, 0)
		RedHue.Font = Enum.Font.SourceSans
		RedHue.FontSize = Enum.FontSize.Size24
		RedHue.Text = "RED Hue Value: "
		RedHue.TextColor3 = Color3.new(1, 1, 1)
		RedHue.TextScaled = true
		RedHue.TextSize = 20
		RedHue.TextStrokeColor3 = Color3.new(1, 0, 0)
		RedHue.TextStrokeTransparency = 0.75
		RedHue.TextWrapped = true

		GreenHue.Name = "GreenHue"
		GreenHue.Parent = CustomizeGui
		GreenHue.BackgroundColor3 = Color3.new(1, 1, 1)
		GreenHue.BackgroundTransparency = 1
		GreenHue.Position = UDim2.new(0.100000001, 0, 0.5, 0)
		GreenHue.Size = UDim2.new(0.300000012, 0, 0.100000001, 0)
		GreenHue.Font = Enum.Font.SourceSans
		GreenHue.FontSize = Enum.FontSize.Size24
		GreenHue.Text = "GREEN Hue Value:"
		GreenHue.TextColor3 = Color3.new(1, 1, 1)
		GreenHue.TextScaled = true
		GreenHue.TextSize = 20
		GreenHue.TextStrokeColor3 = Color3.new(0, 1, 0)
		GreenHue.TextStrokeTransparency = 0.75
		GreenHue.TextWrapped = true

		RedInput.Name = "RedInput"
		RedInput.Parent = CustomizeGui
		RedInput.BackgroundColor3 = Color3.new(0.137255, 0.137255, 0.137255)
		RedInput.BackgroundTransparency = 0.5
		RedInput.BorderSizePixel = 0
		RedInput.Position = UDim2.new(0.419999987, 0, 0.425000007, 0)
		RedInput.Size = UDim2.new(0.200000003, 0, 0.075000003, 0)
		RedInput.Font = Enum.Font.SourceSans
		RedInput.FontSize = Enum.FontSize.Size14
		RedInput.Text = "255"
		RedInput.TextColor3 = Color3.new(1, 1, 1)
		RedInput.TextSize = 14
		RedInput.TextStrokeTransparency = 0

		BlueHue.Name = "BlueHue"
		BlueHue.Parent = CustomizeGui
		BlueHue.BackgroundColor3 = Color3.new(1, 1, 1)
		BlueHue.BackgroundTransparency = 1
		BlueHue.Position = UDim2.new(0.100000001, 0, 0.600000024, 0)
		BlueHue.Size = UDim2.new(0.300000012, 0, 0.100000001, 0)
		BlueHue.Font = Enum.Font.SourceSans
		BlueHue.FontSize = Enum.FontSize.Size24
		BlueHue.Text = "BLUE Hue Value:"
		BlueHue.TextColor3 = Color3.new(1, 1, 1)
		BlueHue.TextScaled = true
		BlueHue.TextSize = 20
		BlueHue.TextStrokeColor3 = Color3.new(0, 0, 1)
		BlueHue.TextStrokeTransparency = 0.75
		BlueHue.TextWrapped = true

		TrailTransparency.Name = "TrailTransparency"
		TrailTransparency.Parent = CustomizeGui
		TrailTransparency.BackgroundColor3 = Color3.new(1, 1, 1)
		TrailTransparency.BackgroundTransparency = 1
		TrailTransparency.Position = UDim2.new(0.090000001, 0, 0.700000024, 0)
		TrailTransparency.Size = UDim2.new(0.310000012, 0, 0.100000001, 0)
		TrailTransparency.Font = Enum.Font.SourceSans
		TrailTransparency.FontSize = Enum.FontSize.Size24
		TrailTransparency.Text = "Trail Transparency:"
		TrailTransparency.TextColor3 = Color3.new(1, 1, 1)
		TrailTransparency.TextScaled = true
		TrailTransparency.TextSize = 20
		TrailTransparency.TextStrokeColor3 = Color3.new(0, 0, 0)
		TrailTransparency.TextWrapped = true

		GreenInput.Name = "GreenInput"
		GreenInput.Parent = CustomizeGui
		GreenInput.BackgroundColor3 = Color3.new(0.137255, 0.137255, 0.137255)
		GreenInput.BackgroundTransparency = 0.5
		GreenInput.BorderSizePixel = 0
		GreenInput.Position = UDim2.new(0.419999987, 0, 0.524999976, 0)
		GreenInput.Size = UDim2.new(0.200000003, 0, 0.075000003, 0)
		GreenInput.Font = Enum.Font.SourceSans
		GreenInput.FontSize = Enum.FontSize.Size14
		GreenInput.Text = "255"
		GreenInput.TextColor3 = Color3.new(1, 1, 1)
		GreenInput.TextSize = 14
		GreenInput.TextStrokeTransparency = 0

		TransInput.Name = "TransInput"
		TransInput.Parent = CustomizeGui
		TransInput.BackgroundColor3 = Color3.new(0.137255, 0.137255, 0.137255)
		TransInput.BackgroundTransparency = 0.5
		TransInput.BorderSizePixel = 0
		TransInput.Position = UDim2.new(0.419999987, 0, 0.725000024, 0)
		TransInput.Size = UDim2.new(0.200000003, 0, 0.075000003, 0)
		TransInput.Font = Enum.Font.SourceSans
		TransInput.FontSize = Enum.FontSize.Size14
		TransInput.Text = "50"
		TransInput.TextColor3 = Color3.new(1, 1, 1)
		TransInput.TextSize = 14
		TransInput.TextStrokeTransparency = 0

		BlueInput.Name = "BlueInput"
		BlueInput.Parent = CustomizeGui
		BlueInput.BackgroundColor3 = Color3.new(0.137255, 0.137255, 0.137255)
		BlueInput.BackgroundTransparency = 0.5
		BlueInput.BorderSizePixel = 0
		BlueInput.Position = UDim2.new(0.419999987, 0, 0.625, 0)
		BlueInput.Size = UDim2.new(0.200000003, 0, 0.075000003, 0)
		BlueInput.Font = Enum.Font.SourceSans
		BlueInput.FontSize = Enum.FontSize.Size14
		BlueInput.Text = "255"
		BlueInput.TextColor3 = Color3.new(1, 1, 1)
		BlueInput.TextSize = 14
		BlueInput.TextStrokeTransparency = 0

		Message.Name = "Message"
		Message.Parent = CustomizeGui
		Message.BackgroundColor3 = Color3.new(1, 1, 1)
		Message.BackgroundTransparency = 1
		Message.Position = UDim2.new(0, 0, 0.2500004, 0)
		Message.Size = UDim2.new(1, 0, 0.100000006, 0)
		Message.Font = Enum.Font.SourceSans
		Message.FontSize = Enum.FontSize.Size18
		Message.Text = "|| Inputs must be values ||"
		Message.TextColor3 = Color3.new(1, 1, 1)
		Message.TextScaled = true
		Message.TextSize = 15
		Message.TextStrokeTransparency = 0.75
		Message.TextWrapped = true

		local attun = Instance.new("Attachment", knife)
		attun.Position = Vector3.new(0, 0.1, -1.75)
		local atdos = Instance.new("Attachment", knife)
		atdos.Position = Vector3.new(0, -0.1, 0.5)
		local trail = Instance.new("Trail", knife)
		trail.LightEmission = 0.5
		trail.Attachment0 = attun
		trail.Attachment1 = atdos
		trail.Lifetime = 0.175
		trail.MinLength = 0
		trail.Enabled = false

		function updatez()
			local rc = tonumber(RedInput.Text)
			local gc = tonumber(GreenInput.Text)
			local bc = tonumber(BlueInput.Text)
			local tcupd = tonumber(TransInput.Text)
			if rc == nil then
				rc = 0
			end
			if gc == nil then
				gc = 0
			end
			if bc == nil then
				bc = 0
			end
			if tcupd == nil then
				tcupd = 0
			end
			local tc = tcupd/100
			Color.BackgroundColor3 = Color3.fromRGB(rc,gc,bc)
			ClosestColor.Text = "Your color is closest to "..tostring(BrickColor.new(Color3.fromRGB(rc,gc,bc)))
			obj32.Color = Color3.fromRGB(rc,gc,bc)
			obj33.Color = Color3.fromRGB(rc,gc,bc)
			obj34.Color = Color3.fromRGB(rc,gc,bc)
			obj35.Color = Color3.fromRGB(rc,gc,bc)
			obj36.Color = Color3.fromRGB(rc,gc,bc)
			obj37.Color = Color3.fromRGB(rc,gc,bc)
			obj38.Color = Color3.fromRGB(rc,gc,bc)
			trail.Color = ColorSequence.new(Color3.fromRGB(rc, gc, bc))
			trail.Transparency = NumberSequence.new(tc)
			TrailTransparency.TextStrokeTransparency = tc
		end

		RedInput.Changed:connect(function(val)
			if val == "Text" and tonumber(RedInput.Text) then
				RedInput.Text = tostring(tonumber(RedInput.Text))
				if tonumber(RedInput.Text) > 255 then
					RedInput.Text = '255'
				end
			elseif val == "Text" then
				RedInput.Text = ""
			end
			updatez()
		end)
		GreenInput.Changed:connect(function(val)
			if val == "Text" and tonumber(GreenInput.Text) then
				GreenInput.Text = tostring(tonumber(GreenInput.Text))
				if tonumber(GreenInput.Text) > 255 then
					GreenInput.Text = '255'
				end
			elseif val == "Text" then
				GreenInput.Text = ""
			end
			updatez()
		end)
		BlueInput.Changed:connect(function(val)
			if val == "Text" and tonumber(BlueInput.Text) then
				BlueInput.Text = tostring(tonumber(BlueInput.Text))
				if tonumber(BlueInput.Text) > 255 then
					BlueInput.Text = '255'
				end
			elseif val == "Text" then
				BlueInput.Text = ""
			end
			updatez()
		end)
		TransInput.Changed:connect(function(val)
			if val == "Text" and tonumber(TransInput.Text) then
				TransInput.Text = tostring(tonumber(TransInput.Text))
				if tonumber(TransInput.Text) > 100 then
					TransInput.Text = '100'
				end
			elseif val == "Text" then
				TransInput.Text = ""
			end
			updatez()
		end)

		Close.MouseButton1Click:connect(function()
			if lerpz == false then
				lerpz = true
				if Close.Text ~= "+" then
					CustomizeGui:TweenPosition(UDim2.new(-0.45,0,0.5,0,Enum.EasingDirection.Out,Enum.EasingStyle.Quint,2))
					for i=1,10 do
						Close.TextTransparency = i/10
						Close.TextStrokeTransparency = i/10
						wait(0.01)
					end
					Close.Text = "+"
					for i=1,10 do
						Close.TextTransparency = (10-i+1)/10
						Close.TextStrokeTransparency = (10-i+1)/10
						wait(0.01)
					end
					lerpz = false
				else
					CustomizeGui:TweenPosition(UDim2.new(0,0,0.5,0,Enum.EasingDirection.Out,Enum.EasingStyle.Quint,2))
					for i=1,10 do
						Close.TextTransparency = i/10
						Close.TextStrokeTransparency = i/10
						wait(0.01)
					end
					Close.Text = "X"
					for i=1,10 do
						Close.TextTransparency = (10-i+1)/10
						Close.TextStrokeTransparency = (10-i+1)/10
						wait(0.01)
					end
					lerpz = false
				end
			end
		end)

		MusicOption.MouseButton1Click:connect(function()
			if canbackgroundmusic == true then
				canbackgroundmusic = false
				MusicOption.BackgroundColor3 = Color3.new(1, 0, 0)
			else
				canbackgroundmusic = true
				MusicOption.BackgroundColor3 = Color3.new(0, 1, 0)
			end
		end)

		ScreenOption.MouseButton1Click:connect(function()
			if cancolorfilter == true then
				cancolorfilter = false
				ScreenOption.BackgroundColor3 = Color3.new(1, 0, 0)
			else
				cancolorfilter = true
				ScreenOption.BackgroundColor3 = Color3.new(0, 1, 0)
			end
		end)

		function equip()
			local doit = coroutine.wrap(function()
				if me:FindFirstChild('Right Arm') and me:FindFirstChild('Torso') then
					acting = true
					local arm = me["Right Arm"]
					local arm2 = me["Left Arm"]
					local tors = me.Torso
					local weld = Instance.new('Weld',arm)
					weld.Part0 = arm
					weld.Part1 = tors
					weld.C0 = CFrame.new(-1.5,0,0)
					local weld2 = Instance.new("Weld", arm2)
					weld2.Part0 = arm2
					weld2.Part1 = tors
					weld2.C0 = CFrame.new(1.5, 0, 0)
					wait(0.001)
					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(-0.2,0.2,-0.5)*CFrame.Angles(0,-3.1,0.9),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(1.5, 0.6, 0) * CFrame.Angles(0,0,0.5),i)
						wait(0.001)
					end
					wait(0.15)
					trail.Enabled = true
					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(-0.5,2,0)*CFrame.Angles(0,0,-1.55),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(1.5, 0, 0), i)
						wait(0.001)
					end
					trail.Enabled = false
					wait(0.2)
					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(-1.5,0,0),i)
						wait(0.001)
					end
					weld:Destroy()
					weld2:Remove()
					if tors ~= nil then
						rightshoulderz:Clone().Parent = me.Torso
						leftshoulderz:Clone().Parent = me.Torso
					end
				end
				acting = false
			end)
			doit()
		end

		function kysnigga()
			if kyssing == true then return end
			kyssing = true
			acting = true
			decearingTHING = math.random(1, 100)
			if decearingTHING == 4 then
				decearingEGG = Instance.new("Sound", me.Torso)
				decearingEGG.SoundId = "rbxassetid://138084557"
				decearingEGG.PlaybackSpeed = math.random(10, 12) / 10
				decearingEGG.TimePosition = 0.2
				decearingEGG:Play()
			end
			me.Humanoid.WalkSpeed = 0
			me.Humanoid.JumpPower = 0

			local rightarm = Instance.new("Weld", me.Torso)
			rightarm.Part0 = me.Torso
			rightarm.Part1 = me["Right Arm"]
			rightarm.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(1.5, 0, 0)

			local leftarm = Instance.new("Weld", me.Torso)
			leftarm.Part0 = me.Torso
			leftarm.Part1 = me["Left Arm"]
			leftarm.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(-1.5, 0, 0)

			local tors = Instance.new("Weld", me.HumanoidRootPart)
			tors.Part0 = me.HumanoidRootPart
			tors.Part1 = me.Torso
			tors.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(0, 0, 0)

			local rightleg = Instance.new("Weld", me.Torso)
			rightleg.Part0 = me.Torso
			rightleg.Part1 = me["Right Leg"]
			rightleg.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(0.5, -2, 0)

			local leftleg = Instance.new("Weld", me.Torso)
			leftleg.Part0 = me.Torso
			leftleg.Part1 = me["Left Leg"]
			leftleg.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(-0.5, -2, 0)

			for i = 0, 1, 0.03 do
				tors.C0 = tors.C0:lerp(CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(-10), 0, 0), i)
				leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-80), 0, 0), i)
				rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-80), 0, 0), i)
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), 0), i)
				wait()
			end
			for i = 0, 1, 0.03 do
				tors.C0 = tors.C0:lerp(CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(5), 0, 0), i)
				leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -1, 0.15) * CFrame.Angles(math.rad(-95), 0, 0), i)
				rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -1, 0.15) * CFrame.Angles(math.rad(-95), 0, 0), i)
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1, 0.3, -1.5) * CFrame.Angles(math.rad(90), 0, math.rad(-35)), i)
				leftarm.C0 = leftarm.C0:lerp(CFrame.new(-1, 0.3, -1.5) * CFrame.Angles(math.rad(90), 0, math.rad(35)), i)
				knifeweld.C1 = knifeweld.C1:lerp(CFrame.new(1.35, 0, 1) * CFrame.Angles(1.55, math.rad(-180), 1), i)
				wait()
			end
			local bleedzer = Instance.new('Part',me.Torso)
			bleedzer.CFrame = me.Torso.CFrame
			bleedzer.Size = Vector3.new(0.1,0.1,0.1)
			bleedzer.Transparency = 1
			bleedzer.CanCollide = false
			local weld = Instance.new('Weld',bleedzer)
			weld.Part0 = bleedzer
			weld.Part1 = me.Torso
			weld.C0= CFrame.new(0,0,0)*CFrame.Angles(math.rad(-90),0,0)
			local woodpekker = coroutine.wrap(function()
				bleed(bleedzer)
			end)
			woodpekker()
			audio.SoundId = "rbxassetid://199977936"
			audio.PlaybackSpeed = 1.5
			audio:Play()
			audio2.SoundId = "rbxassetid://220834019"
			audio2.PlaybackSpeed = 1
			audio2.TimePosition = 0.1
			audio2:Play()
			for i = 0, 1, 0.1 do
				tors.C0 = tors.C0:lerp(CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(-20), 0, 0), i)
				leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -1, -0.35) * CFrame.Angles(math.rad(-70), 0, 0), i)
				rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -1, -0.35) * CFrame.Angles(math.rad(-70), 0, 0), i)
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1, 0, 0) * CFrame.Angles(math.rad(70), 0, math.rad(-35)), i)
				leftarm.C0 = leftarm.C0:lerp(CFrame.new(-1, 0, 0) * CFrame.Angles(math.rad(70), 0, math.rad(35)), i)
				knifeweld.C1 = knifeweld.C1:lerp(CFrame.new(1.35, 0, 1) * CFrame.Angles(1.55, math.rad(-180), 1), i)
				wait()
			end
			wait(1)
			audio.SoundId = "rbxassetid://210943487"
			audio.TimePosition = 0.2
			audio.PlaybackSpeed = 0.75
			audio:Play()
			for i = 0, 1, 0.03 do
				tors.C0 = tors.C0:lerp(CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(-20), 0, 0), i)
				leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -1, -0.35) * CFrame.Angles(math.rad(-70), 0, 0), i)
				rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -1, -0.35) * CFrame.Angles(math.rad(-70), 0, 0), i)
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1, 0.3, -1.5) * CFrame.Angles(math.rad(70), 0, math.rad(-35)), i)
				leftarm.C0 = leftarm.C0:lerp(CFrame.new(-1, 0.3, -1.5) * CFrame.Angles(math.rad(70), 0, math.rad(35)), i)
				knifeweld.C1 = knifeweld.C1:lerp(CFrame.new(1.35, 0, 1) * CFrame.Angles(1.55, math.rad(-180), 1), i)
				wait()
			end
			for i = 0, 1, 0.03 do
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5, 0, -0.4) * CFrame.Angles(math.rad(30), 0, math.rad(0)), i)
				leftarm.C0 = leftarm.C0:lerp(CFrame.new(-1.5, 0, -0.4) * CFrame.Angles(math.rad(30), 0, math.rad(0)), i)
				knifeweld.C1 = knifeweld.C1:lerp(CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), 1.55) * CFrame.new(0, 0.95, 0), i)
				wait()
			end
			wait(0.24)
			if me:FindFirstChildOfClass('Humanoid') then
				me:FindFirstChildOfClass('Humanoid').Health = 0
			end
			wait(0.01)
			killz(me,me.Torso.Name,nil,nil,true)

			tors:Remove()
			rightarm:Remove()
			rightleg:Remove()
			leftleg:Remove()
			leftarm:Remove()
			rightshoulderz:Clone().Parent = me.Torso
			leftshoulderz:Clone().Parent = me.Torso
			torsojoint:Clone().Parent = me.HumanoidRootPart
			lefthipz:Clone().Parent = me.Torso
			righthipz:Clone().Parent = me.Torso
			me.Humanoid.JumpPower = 50
			me.Humanoid.WalkSpeed = 16
			acting = false
			canClick = true
			doing = false
			hit = false
			kyssing = false
			if decearingTHING == 4 then
				decearingEGG:Remove()
			end
		end

		function bleedout()
			local doit = coroutine.wrap(function()
				local targe = grabbed
				local num = 0
				while targe and targe:FindFirstChildOfClass('Humanoid') and targe:FindFirstChildOfClass('Humanoid').Health > 0 and num < 11 do
					if targe.Head:FindFirstChild('Died') then
						tone = math.random(6, 12) / 10
						targe.Head.Died.PlaybackSpeed = tone
						targe.Head.Died:Play()
					else
						local deathsound = Instance.new('Sound',targe.Head)
						deathsound.Name = "Died"
						deathsound.SoundId = 'rbxasset://sounds/uuhhh.mp3'
						deathsound.Volume = 0.65
						deathsound.EmitterSize = 5
						deathsound.MaxDistance = 150
						tone = math.random(5, 15) / 10
						targe.Head.Died.PlaybackSpeed = tone
						targe.Head.Died:Play()
					end
					targe:FindFirstChildOfClass('Humanoid').Health = targe:FindFirstChildOfClass('Humanoid').Health - 7
					num = num+1
					wait(0.325)
				end
				targe:FindFirstChildOfClass('Humanoid').Health = 0
				wait()
				killz(targe,'Head',nil,nil,false,true)
				wait(2)
				targe:Remove()
			end)
			doit()
		end

		function liedown()
			local doit = coroutine.wrap(function()
				local targe = grabbed
				wait(2)
				if targe and targe:FindFirstChildOfClass('Humanoid') then
					targe:FindFirstChildOfClass('Humanoid').PlatformStand = false
				end
			end)
			doit()
		end

		function grab()
			local doit = coroutine.wrap(function()
				acting = true
				me:FindFirstChildOfClass('Humanoid').WalkSpeed = me:FindFirstChildOfClass('Humanoid').WalkSpeed + 3
				local arm = me["Right Arm"]
				local tors = me.Torso
				local arm2 = me["Left Arm"]
				local humanroot = me.HumanoidRootPart
				local weld2 = Instance.new('Weld',arm)
				weld2.Part0 = arm
				weld2.Part1 = tors
				weld2.C0 = CFrame.new(-1.5,0,0) * CFrame.Angles(0, 0, 0)
				local weld3 = Instance.new('Weld',arm2)
				weld3.Part0 = arm2
				weld3.Part1 = tors
				weld3.C0 = CFrame.new(1.5,0,-0.3) * CFrame.Angles(0.3,0.1,0)
				for i = 0,1,0.05 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or humanroot == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-1.2,1.3,0.4)*CFrame.Angles(0.5,0,-1.2),i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(1.2,1.3,0)*CFrame.Angles(0,0,1.2),i)
					knifeweld.C1 = CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), -1.55) * CFrame.new(0, 0.95, 0)
					wait(0.01)
				end
				grabbing = true
				trail.Enabled = true
				for i = 0,1,0.10 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or humanroot == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 0.80, -1.1)* CFrame.Angles(-1.5, 0, -1.3), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 1, -0.5)* CFrame.Angles(-1.5, 0, 1.1), i)
					wait(0.01)
				end
				trail.Enabled = false
				wait(0.5)
				grabbing = false
				me:FindFirstChildOfClass('Humanoid').WalkSpeed = me:FindFirstChildOfClass('Humanoid').WalkSpeed - 3
				if grabbed == nil then
					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil then return end
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
						weld3.C0 = weld3.C0:lerp(CFrame.new(1.5,0,0),i)
						knifeweld.C1 = CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), 1.55) * CFrame.new(0, 0.95, 0)
						wait(0.001)
					end
					weld2:Destroy()
					weld3:Destroy()
					rightshoulderz:Clone().Parent = me.Torso
					leftshoulderz:Clone().Parent = me.Torso
					acting = false
					canClick = true
				end
			end)
			doit()
		end

		function kill()
			for i, plr in pairs(game.Players:GetChildren()) do
				if plr.Name ~= game.Players.LocalPlayer.Name then
					for i = 1, 10 do
						game.ReplicatedStorage.meleeEvent:FireServer(plr)
					end
				end
			end

			targetweld3pt = grabbed:FindFirstChild("Right Arm")
			local targetrightshoulder = rightshoulder
			local targetleftshoulder = leftshoulder
			local targetweld3 = Instance.new("Weld", targetweld3pt)
			targetweld3.Part0 = grabbed.Torso
			targetweld3.Part1 = targetweld3pt
			targetweld3.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(1.5, 0, 0)

			local doit = coroutine.wrap(function()
				local arm = me["Right Arm"]
				local tors = grabbed.Torso
				local arm2 = me["Left Arm"]
				if arm:FindFirstChildOfClass('Weld') == nil or arm2:FindFirstChildOfClass('Weld') == nil then return end
				doing = true
				local weld2 = arm:FindFirstChildOfClass('Weld')
				local weld3 = arm2:FindFirstChildOfClass('Weld')
				local humanroot = me.HumanoidRootPart

				for i = 0,1,0.1 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or weld3 == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 0.80, -1.1)* CFrame.Angles(-1.9, 0, -1.4), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 0.5, -0.5)* CFrame.Angles(-1.5, 0.4, 1.1), i)
					wait(0.01)
				end

				audio:Stop()
				audio.SoundId = "rbxassetid://517040733"
				tone = math.random(1, 3)
				if tone == 1 then audio.PlaybackSpeed = 0.8 audio.TimePosition = 0.3 end
				if tone == 2 then audio.PlaybackSpeed = 1 audio.TimePosition = 0.1 end
				if tone == 3 then audio.PlaybackSpeed = 1.2 audio.TimePosition = 0.2 end
				audio:Play()

				local bleedpart = Instance.new("Part", grabbed)
				bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
				bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
				bleedpart.CanCollide = false
				bleedpart.Position = grabbed.Head.Position + Vector3.new(0, 1, 0)
				bleedpart.Transparency = 1

				local bleedpartweld = Instance.new("Weld", grabbed.Torso)
				bleedpartweld.Part0 = grabbed.Torso
				bleedpartweld.Part1 = bleedpart
				bleedpartweld.C0 = CFrame.Angles(-1, 0, -0.35) * CFrame.new(0, 1, 0.8)
				local coru=coroutine.wrap(function()
					bleed(bleedpart)
				end)
				coru()

				local slightthrow = Instance.new("BodyThrust", grabbed.Torso)
				slightthrow.Force = Vector3.new(0, 0, -2500)

				local slightthrow2 = Instance.new("BodyAngularVelocity", grabbed.Torso)
				slightthrow2.AngularVelocity = Vector3.new(0, -1000, 0)
				slightthrow2.MaxTorque = Vector3.new(1000, 1000, 1000)

				if grabbed:FindFirstChildOfClass('Humanoid') then
					grabbed:FindFirstChildOfClass('Humanoid').PlatformStand = true
				end

				killz(grabbed,'Left Leg')
				killz(grabbed,'Left Arm')
				killz(grabbed,'Right Leg')
				killz(grabbed,'Right Arm')

				trail.Enabled = true

				for i = 0,1,0.2 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or weld3 == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 1.7, -0.5)* CFrame.Angles(-0.25, 0, -1.4), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 1.6, -0.5)* CFrame.Angles(-1.5, -1, 1.1), i)
					wait(0.01)
				end

				trail.Enabled = false

				bleedout()

				rightshoulderz:Clone().Parent = me.Torso
				leftshoulderz:Clone().Parent = me.Torso
				grabbed = nil

				if humanroot:FindFirstChild('Holder') then
					humanroot.Holder:Destroy()
				end

				wait(0.2)
				slightthrow:Remove()
				slightthrow2:Remove()
				for i = 0,1,0.05 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or weld3 == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5, 0, 0)* CFrame.Angles(0, 0, 0), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(1.5, 0, 0)* CFrame.Angles(0, 0, 0), i)
					knifeweld.C1 = CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), 1.55) * CFrame.new(0, 0.95, 0)
					wait(0.01)
				end

				weld2:Destroy()
				weld3:Destroy()
				targetweld = nil
				targetweld2 = nil
				targetweld3 = nil
				rightshoulderz:Clone().Parent = me.Torso
				leftshoulderz:Clone().Parent = me.Torso
				acting = false
				canClick = true
				doing = false
			end)
			doit()
		end

		function finish()
			if finishing == true then return end
			finishing = true
			acting = true
			decearingTHING = math.random(1, 100)
			if decearingTHING == 4 then
				decearingEGG = Instance.new("Sound", me.Torso)
				decearingEGG.SoundId = "rbxassetid://138084557"
				decearingEGG.PlaybackSpeed = math.random(10, 12) / 10
				decearingEGG.TimePosition = 0.2
				decearingEGG:Play()
			end
			me.Humanoid.WalkSpeed = 0
			me.Humanoid.JumpPower = 0

			local rightarm = Instance.new("Weld", me.Torso)
			rightarm.Part0 = me.Torso
			rightarm.Part1 = me["Right Arm"]
			rightarm.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(1.5, 0, 0)

			local tors = Instance.new("Weld", me.HumanoidRootPart)
			tors.Part0 = me.HumanoidRootPart
			tors.Part1 = me.Torso
			tors.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(0, 0, 0)

			local rightleg = Instance.new("Weld", me.Torso)
			rightleg.Part0 = me.Torso
			rightleg.Part1 = me["Right Leg"]
			rightleg.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(0.5, -2, 0)

			local leftleg = Instance.new("Weld", me.Torso)
			leftleg.Part0 = me.Torso
			leftleg.Part1 = me["Left Leg"]
			leftleg.C0 = CFrame.Angles(0, 0, 0) * CFrame.new(-0.5, -2, 0)

			for i = 0, 1, 0.05 do
				tors.C0 = tors.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), 0, 0), i)
				leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -2, 0.2) * CFrame.Angles(math.rad(-15), 0, 0), i)
				rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -2, 0.2) * CFrame.Angles(math.rad(-15), 0, 0), i)
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5, 1.9, 0) * CFrame.Angles(math.rad(179), math.rad(179), 0), i)
				wait()
			end
			for i=1,finishnum do
				local num1 = 0.5
				local num2 = 0.5
				local num3 = 0.25
				if finishnum ~= 1 then
					num3 = 0
				end
				trail.Enabled = true
				for i = 0, 1, num1 do
					tors.C0 = tors.C0:lerp(CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(-60), 0, 0), i)
					leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -1.5, 0) * CFrame.Angles(math.rad(0), 0, 0), i)
					rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -0.7, -1) * CFrame.Angles(math.rad(10), 0, 0), i)
					rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5, 1.9, -1) * CFrame.Angles(math.rad(160), math.rad(150), 0), i)
					wait()
				end
				wait()
				for i = 0, 1, num2 do
					tors.C0 = tors.C0:lerp(CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-20), 0, 0), i)
					leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -1.5, 0) * CFrame.Angles(math.rad(-30), 0, 0), i)
					rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -0.7, -1) * CFrame.Angles(math.rad(-20), 0, 0), i)
					rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5, 1.9, 0.2) * CFrame.Angles(math.rad(250), math.rad(180), 0), i)
					wait()
				end
				trail.Enabled = false
				wait(num3)
			end
			wait()
			for i = 0, 1, 0.05 do
				tors.C0 = tors.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), i)
				leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5, -2, 0) * CFrame.Angles(0, 0, 0), i)
				rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5, -2, 0) * CFrame.Angles(0, 0, 0), i)
				rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5, 0, 0) * CFrame.Angles(0, 0, 0), i)
				wait()
			end
			tors:Remove()
			rightarm:Remove()
			rightleg:Remove()
			leftleg:Remove()
			rightshoulderz:Clone().Parent = me.Torso
			leftshoulderz:Clone().Parent = me.Torso
			torsojoint:Clone().Parent = me.HumanoidRootPart
			lefthipz:Clone().Parent = me.Torso
			righthipz:Clone().Parent = me.Torso
			me.Humanoid.JumpPower = 50
			me.Humanoid.WalkSpeed = 16
			acting = false
			canClick = true
			doing = false
			hit = false
			finishing = false
			if decearingTHING == 4 then
				decearingEGG:Remove()
			end
		end

		function throw()
			if grabbed.Torso:FindFirstChild("TargetWeld") == nil or grabbed:FindFirstChildOfClass('Humanoid').Health <= 0 then return end
			paralyzed = false
			targetweld = grabbed.Torso.TargetWeld
			local ree = grabbed:FindFirstChild("Left Arm")
			targetweld2 =nil
			if ree and ree:FindFirstChild("Weld") then
				targetweld2 = ree.Weld
			end

			for i, v in pairs(grabbed:GetChildren()) do
				if v.Name == "Part" then
					v.CanCollide = true
				end
			end


			local doit = coroutine.wrap(function()
				local arm = me["Right Arm"]
				local tors = grabbed.Torso
				local arm2 = me["Left Arm"]
				local targrightshoulder = rightshoulder

				local targleftshoulder = leftshoulder
				if arm:FindFirstChildOfClass('Weld') == nil or arm2:FindFirstChildOfClass('Weld') == nil then return end
				doing = true
				local weld2 = arm:FindFirstChildOfClass('Weld')
				local weld3 = arm2:FindFirstChildOfClass('Weld')
				local humanroot = me.HumanoidRootPart

				for i = 0,1,0.2 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or weld3 == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 1.7, -0.5)* CFrame.Angles(-0.25, 1, -1.4), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 1.6, -0.5)* CFrame.Angles(-1.5, -1, 1.1), i)
					targetweld.C0 = targetweld.C0:lerp(CFrame.new(0, 1.5, 0)*CFrame.Angles(0, 0, 0), i)
					if targetweld2 then
						targetweld2.C0 = targetweld2.C0:lerp(CFrame.new(-1.5, 0, 0)*CFrame.Angles(0, 0, 0), i)
					end
					wait(0.01)
				end

				audio:Stop()
				audio.SoundId = "rbxassetid://536642316"
				tone = math.random(1, 3)
				if tone == 1 then audio.PlaybackSpeed = 0.8 audio.TimePosition = 0.08 end
				if tone == 2 then audio.PlaybackSpeed = 1 audio.TimePosition = 0.1 end
				if tone == 3 then audio.PlaybackSpeed = 1.2 audio.TimePosition = 0.12 end
				audio:Play()

				local slightthrow = Instance.new("BodyVelocity", grabbed.Torso)
				slightthrow.Velocity = Vector3.new(0,20,0)+(me.Torso.CFrame.lookVector*20)
				slightthrow.P = 5000
				slightthrow.MaxForce = Vector3.new(9000001,9000001,9000001)
				local point = grabbed.Torso.Position
				local aaaaaa = grabbed
				liedown()

				rightshoulderz:Clone().Parent = me.Torso
				leftshoulderz:Clone().Parent = me.Torso
				grabbed = nil

				if humanroot:FindFirstChild('Holder') then
					humanroot.Holder:Destroy()
				end
				local coru = coroutine.wrap(function()
					while aaaaaa and aaaaaa:FindFirstChild('Torso') and (aaaaaa.Torso.Position-point).magnitude < 5 do wait(0.001) end
					slightthrow:Remove()
				end)
				coru()

				for i = 0,1,0.05 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or weld3 == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(1.5,0,0),i)
					wait(0.01)
				end
				weld2:Destroy()
				weld3:Destroy()
				targetweld:Remove()
				if targetweld2 then
					targetweld2:Remove()
				end
				if rightshoulder then
					rightshoulder:Clone().Parent = tors
				end
				if leftshoulder then
					leftshoulder:Clone().Parent = tors
				end
				headweld:Clone().Parent = tors
				rightshoulderz:Clone().Parent = me.Torso
				leftshoulderz:Clone().Parent = me.Torso
				acting = false
				canClick = true
				doing = false
			end)
			doit()
		end

		cfn,ang,mr,int=CFrame.new,CFrame.Angles,math.rad,Instance.new
		bc=BrickColor.new
		local minimumsize = Vector3.new(0.7,0.7,0.7) 
		local surface_between_splitted_parts = 'SmoothNoOutlines'
		local fragmentable = workspace
		local list = {}
		local brickcount = 0
		local storage = {}
		local fillup = 1000
		local maximumstorage = 2000 
		local storage_position = Vector3.new(0,0,5000) 
		local stored_partsize = Vector3.new(1,1,1) 
		local parts_created_per_frame = 5 

		local minimumsize = Vector3.new(0.7,0.7,0.7) 
		local surface_between_splitted_parts = 'SmoothNoOutlines'
		local fragmentable = workspace
		local list = {}
		local brickcount = 0
		local storage = {}
		local fillup = 1000
		local maximumstorage = 2000
		local storage_position = Vector3.new(0,0,5000) 
		local stored_partsize = Vector3.new(1,1,1)
		local parts_created_per_frame = 5 


		function fragmentate(cframe,size,color,explosion_position,explosion_blastradius,backsurface,bottomsurface,frontsurface,leftsurface,rightsurface,topsurface,transparency,reflectance,material)
			local xi = size.X >= minimumsize.X*(1+explosion_blastradius/16) and 2 or 1 
			local yi = size.Y >= minimumsize.Y*(1+explosion_blastradius/16) and 2 or 1
			local zi = size.Z >= minimumsize.Z*(1+explosion_blastradius/16) and 2 or 1
			if xi == 1 and yi == 1 and zi == 1 or (cframe.p-explosion_position).magnitude > size.magnitude/2 + explosion_blastradius then 
				if xi == 1 and yi == 1 and zi == 1 then return end 
				if #storage > 0 then
					local p = storage[1]
					p.BrickColor = color
					p.Size = size
					p.Anchored = false
					p.BackSurface = backsurface
					p.BottomSurface = bottomsurface
					p.FrontSurface = frontsurface
					p.LeftSurface = leftsurface
					p.RightSurface = rightsurface
					p.TopSurface = topsurface
					p.Transparency = transparency
					p.CFrame = cframe
					p.Reflectance = reflectance
					p.Material = material
					game:GetService('Debris'):AddItem(p,30)
					p:BreakJoints()
					table.remove(storage,1)
				else
					local p = Instance.new("Part",fragmentable)
					p.BrickColor = color
					p.FormFactor = "Custom"
					p.Size = size
					p.BackSurface = backsurface
					p.BottomSurface = bottomsurface
					p.FrontSurface = frontsurface
					p.LeftSurface = leftsurface
					p.RightSurface = rightsurface
					p.TopSurface = topsurface
					p.Transparency = transparency
					p.Material = material
					if p.Transparency>0.285 then
						p.Anchored = false
					else
						p.Anchored=false
						p.Material='Wood'
						game:GetService('Debris'):AddItem(p,10)
					end
					p.CFrame = cframe
					p.Reflectance = reflectance
					p:BreakJoints()
				end
				return 
			end
			local mody = math.random(-125,125)/1000
			for y = 1,yi do
				if math.random()> 0.5 then
					local modx = math.random(-125,125)/1000
					for x = 1,xi do
						local modz = math.random(-125,125)/1000
						for z = 1,zi do --offset = x/xi-0.75+modx)
							fragmentate(cframe*CFrame.new(size.X*(xi==1 and 0 or x/xi-0.75+modx),size.Y*(yi==1 and 0 or y/yi-0.75+mody),size.Z*(zi==1 and 0 or z/zi-0.75+modz)),
								Vector3.new(xi == 2 and size.X*(1-2*math.abs(x/xi-0.75+modx)) or size.X,yi == 2 and size.Y*(1-2*math.abs(y/yi-0.75+mody)) or size.Y,
									zi == 2 and size.Z*(1-2*math.abs(z/zi-0.75+modz)) or size.Z or mustardfoot_was_here),color,explosion_position,explosion_blastradius,
								z~=zi and surface_between_splitted_parts or backsurface,y==2 and surface_between_splitted_parts or bottomsurface,
								z==2 and surface_between_splitted_parts or frontsurface,x==2 and surface_between_splitted_parts or leftsurface,x~=xi and surface_between_splitted_parts or rightsurface,
								y~=yi and surface_between_splitted_parts or topsurface,transparency,reflectance,material) 
						end

					end
				else
					local modz = math.random(-125,125)/1000
					for z = 1,zi do
						local modx = math.random(-125,125)/1000
						for x = 1,xi do
							fragmentate(cframe*CFrame.new(size.X*(xi==1 and 0 or x/xi-0.75+modx),size.Y*(yi==1 and 0 or y/yi-0.75+mody),size.Z*(zi==1 and 0 or z/zi-0.75+modz)),
								Vector3.new(xi == 2 and size.X*(1-2*math.abs(x/xi-0.75+modx)) or size.X,yi == 2 and size.Y*(1-2*math.abs(y/yi-0.75+mody)) or size.Y,
									zi == 2 and size.Z*(1-2*math.abs(z/zi-0.75+modz)) or size.Z),color,explosion_position,explosion_blastradius,
								z~=zi and surface_between_splitted_parts or backsurface,y==2 and surface_between_splitted_parts or bottomsurface,
								z==2 and surface_between_splitted_parts or frontsurface,x==2 and surface_between_splitted_parts or leftsurface,x~=xi and surface_between_splitted_parts or rightsurface,
								y~=yi and surface_between_splitted_parts or topsurface,transparency,reflectance,material)
						end
					end
				end
			end             
		end

		function start_fragmentation(position,radius,nuh)
			local search = Region3.new(position-Vector3.new(radius,radius,radius)*1.1,position+Vector3.new(radius,radius,radius)*1.1)
			repeat
				local finish = false
				local parts = workspace:FindPartsInRegion3WithIgnoreList(search,list,100)
				for i = 1,#parts do
					table.insert(list,1,parts[i])
				end
				finish = true
			until #parts < 100 and finish
			local t = tick()
			for i = 1,#list do
				local p = list[i]
				if p:IsA('UnionOperation') == false and p:IsA('CornerWedgePart') == false and p:IsA('TrussPart') == false and p:IsA('WedgePart') == false and p.Parent and p.Parent ~= obj1 and p.Parent.Name ~= "Projectile" and p:IsDescendantOf(fragmentable) and p:GetMass()<50000 and p.Transparency>0.285 and p.Name~='Base' and p.Parent:FindFirstChildOfClass('Humanoid') == nil and p.Parent.Parent:FindFirstChildOfClass('Humanoid') == nil and p:IsDescendantOf(me)==false then
					fragmentate(p.CFrame,p.Size,p.BrickColor,position,radius,p.BackSurface,p.BottomSurface,p.FrontSurface,p.LeftSurface,p.RightSurface,p.TopSurface,p.Transparency,p.Reflectance,p.Material)
					if #storage < maximumstorage and p.Shape == "Block" then 
						p.Anchored = false
						p.FormFactor = "Custom"
						p.Size = stored_partsize
						p.Position = storage_position
						table.insert(storage,1,p)
					else 
						p:Destroy()
					end
				end
				if nuh == false and p.Parent and p.Parent ~= obj1 and p.Parent.Name ~= "Projectile" and p:IsDescendantOf(fragmentable) and p:GetMass()<53000 and p.Transparency<0.05 and p.Name~='Base' and tostring(p.Material)=='Enum.Material.Wood' and p:IsDescendantOf(me)==false then
					fragmentate(p.CFrame,p.Size,p.BrickColor,position,radius,p.BackSurface,p.BottomSurface,p.FrontSurface,p.LeftSurface,p.RightSurface,p.TopSurface,p.Transparency,p.Reflectance,p.Material)
					if #storage < maximumstorage and p.Shape == "Block" then
						p.Anchored = false
						p.Material='Wood'
						p.FormFactor = "Custom"
						p.Size = stored_partsize
						p.Position = storage_position
						table.insert(storage,1,p)
					else 
						p:Destroy()
					end
				end
			end 
			list = {}
		end


		function fling()
			local doit = coroutine.wrap(function()
				if me:FindFirstChild('Right Arm') and me:FindFirstChild('Torso') and me:FindFirstChild('HumanoidRootPart') then
					acting = true
					for i=1,finishnum do
						local weld2 = Instance.new('Weld',me["Right Arm"])
						weld2.Part0 = me["Right Arm"]
						weld2.Part1 = me["Torso"]
						weld2.C0 = CFrame.new(-1.5,0,0)
						if finishnum == 1 then
							for i = 0,1,0.05 do
								if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
								weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0.9,-0.5)*CFrame.Angles(-math.pi/0.75,-math.pi/8,0),i)
								wait(0.01)  
							end
						end
						audio.SoundId = "rbxassetid://166083610"
						audio.PlaybackSpeed = 1
						audio.TimePosition = 0.1
						audio:Play()
						if finishnum == 1 then
							for i = 0,1,0.5 do
								if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
								weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0),i)
								wait(0.001) 
							end
						end
						weld2.C0 = CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0)
						local knofe = obj1:Clone()
						for i, v in pairs(obj1:GetChildren()) do
							if v:IsA('BasePart') then
								v.Transparency = 1
							end
						end
						knofe.Parent = workspace
						knofe.Name = "Projectile"
						knofe.Grab.CFrame = CFrame.new(knofe.Grab.CFrame.p, mouse.Hit.p)*CFrame.Angles(0,math.pi/2,0)
						knofe:FindFirstChild("Trail", true).Enabled = true
						local heck = Instance.new('BodyVelocity',knofe.Grab)
						heck.Velocity = (knofe.Grab.CFrame*CFrame.Angles(0,math.pi/-2,0)).lookVector*120
						local coru = coroutine.wrap(function()
							wait(0.45)
							if heck then
								heck:Destroy()
							end
						end)
						coru()
						local able = true
						knofe["big ass knife"].Touched:connect(function(hit)
							if hit.Parent and hit.Parent:FindFirstChildOfClass('Humanoid') and hit.Transparency < 1 and knofe.Grab.CanCollide == false and hit.Parent ~= me and hit.Parent.Parent ~= me then
								local thing = hit.Parent:FindFirstChildOfClass('Humanoid')
								local ree = hit.Parent
								if thing == nil then
									ree = hit.Parent.Parent
								end
								if ree:FindFirstChildOfClass('Humanoid').Health > 0 then
									knofe:FindFirstChild("Trail", true).Enabled = false
									game:GetService('Debris'):AddItem(knofe,5)
									tone = math.random(1, 3)
									local sound = Instance.new('Sound',knofe.Grab)
									if tone == 1 then sound.SoundId = "rbxassetid://220833967" end
									if tone == 2 then sound.SoundId = "rbxassetid://220833976" end
									if tone == 3 then sound.SoundId = "rbxassetid://220834000" end
									sound.PlaybackSpeed = 1
									sound:Play()
									for i, v in pairs(knofe:GetChildren()) do
										if v:IsA('BasePart') then
											v.CanCollide = true
											v.Anchored = true
										end
									end
									hit.Anchored = true
									if ree:FindFirstChildOfClass('Humanoid') and hit.Name == "Torso" or hit.Name == "Head" then
										ree:FindFirstChildOfClass('Humanoid').Health = 0
									end
									wait()
									killz(ree,hit.Name,knofe)
								else
									knofe:FindFirstChild("Trail", true).Enabled = false
									heck.Velocity = Vector3.new(0,0,0)
									heck:Destroy()
									game:GetService('Debris'):AddItem(knofe,5)
									tone = math.random(1, 3)
									local sound = Instance.new('Sound',knofe.Grab)
									if tone == 1 then sound.SoundId = "rbxassetid://220833967" end
									if tone == 2 then sound.SoundId = "rbxassetid://220833976" end
									if tone == 3 then sound.SoundId = "rbxassetid://220834000" end
									sound.PlaybackSpeed = 1
									sound:Play()
									for i, v in pairs(knofe:GetChildren()) do
										if v:IsA('BasePart') then
											v.Anchored = false
										end
									end
									hit.Anchored = true
									wait(0.001)
									hit.Anchored = false
									for i, v in pairs(knofe:GetChildren()) do
										if v:IsA('BasePart') then
											v.Anchored = false
										end
									end
									if knofe then
										local coru = coroutine.wrap(function()
											if hit then
												local uno = Instance.new('Part',workspace)
												local dos = Instance.new('Part',workspace)
												uno.CFrame = hit.CFrame
												dos.CFrame = knofe["big ass knife"].CFrame
												local weld = Instance.new('Weld',knofe["big ass knife"])
												weld.Part0 = hit
												weld.Part1 = knofe["big ass knife"]
												weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
												uno:Destroy()
												dos:Destroy()
											end
										end)
										coru()
									end
								end
							elseif hit.Parent and hit.Parent ~= me and hit.Parent.Parent ~= me and hit.CanCollide and knofe.Grab.CanCollide == false then
								if hit.Transparency and (hit.Transparency<=0.285 or hit:GetMass()<=3000) then
									knofe:FindFirstChild("Trail", true).Enabled = false
									local sound = Instance.new('Sound',knofe.Grab)
									sound.SoundId = 'rbxassetid://267585646'
									sound:Play()
									for i,v in pairs(knofe:GetChildren()) do
										if v:IsA('BasePart') then
											v.Anchored = true
										end
									end
									wait()
									heck.Velocity = Vector3.new(0,0,0)
									heck:Destroy()
									local uno = Instance.new('Part',workspace)
									local dos = Instance.new('Part',workspace)
									uno.CFrame = hit.CFrame
									dos.CFrame = knofe["big ass knife"].CFrame
									local weld = Instance.new('Weld',knofe["big ass knife"])
									weld.Part0 = hit
									weld.Part1 = knofe["big ass knife"]
									weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
									uno:Destroy()
									dos:Destroy()
									for i,v in pairs(knofe:GetChildren()) do
										if v:IsA('BasePart') then
											v.Anchored = false
										end
									end
									game:GetService('Debris'):AddItem(knofe,5)
									for i,v in pairs(knofe:GetChildren()) do
										if v:IsA('BasePart') then
											v.CanCollide = true
										end
									end
								end
								if hit.Parent and hit.Transparency>0.285 and able == true and hit:GetMass()<3000 and hit.Parent:FindFirstChildOfClass('Humanoid') == nil and (hit.Parent.Parent == nil or hit.Parent.Parent:FindFirstChildOfClass('Humanoid') == nil) then
									knofe:FindFirstChild("Trail", true).Enabled = false
									able = false
									local sound = Instance.new('Sound',knofe.Grab)
									sound.SoundId = 'rbxassetid://144884907'
									sound:Play()
									local coru = coroutine.wrap(function()
										start_fragmentation(knofe["big ass knife"].Position,1.25,knofe)
									end)
									coru()
								end
							end
						end)
						if finishnum == 1 then
							for i= 0,1,0.1 do
								if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
								weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
								wait(0.001)
							end
						else
							for i= 0,1,0.5 do
								if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
								weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
								wait(0.001)
							end
						end
						for i,v in pairs(obj1:GetChildren()) do
							if v:IsA('BasePart') then
								v.Transparency = 0
							end
						end
						weld2:Destroy()
						rightshoulderz:Clone().Parent = me.Torso
					end
					acting = false
					canClick = true
				end
			end)
			doit()
		end

		function instasplode()
			local coru = coroutine.wrap(function()
				acting = true
				for i=1,1 do
					local weld2 = Instance.new('Weld',me["Right Arm"])
					weld2.Part0 = me["Right Arm"]
					weld2.Part1 = me["Torso"]
					weld2.C0 = CFrame.new(-1.5,0,0)
					if finishnum == 1 then
						for i = 0,1,0.05 do
							if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
							weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0.9,-0.5)*CFrame.Angles(-math.pi/0.75,-math.pi/8,0),i)
							wait(0.01)  
						end
					end
					weld2.C0 = CFrame.new(-1.5,0.9,-0.5)*CFrame.Angles(-math.pi/0.75,-math.pi/8,0)
					audio.SoundId = "rbxassetid://166083610"
					audio.PlaybackSpeed = 1
					audio.TimePosition = 0.1
					audio:Play()
					if finishnum == 1 then
						for i = 0,1,0.5 do
							if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
							weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0),i)
							wait(0.001) 
						end
					end
					weld2.C0 = CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0)
					local knofe = obj1:Clone()
					for i,v in pairs(obj1:GetChildren()) do
						if v:IsA('BasePart') then
							v.Transparency = 1
						end
					end
					knofe.Parent = workspace
					knofe.Name = "Projectile"
					knofe.Grab.CFrame = CFrame.new(knofe.Grab.CFrame.p, mouse.Hit.p)*CFrame.Angles(0,math.pi/2,0)
					knofe:FindFirstChild("Trail", true).Enabled = false
					fireofjesUS = Instance.new("Fire", knofe.Grab)
					local heck = Instance.new('BodyVelocity',knofe.Grab)
					heck.Velocity = (knofe.Grab.CFrame*CFrame.Angles(0,math.pi/-2,0)).lookVector*120
					local coru = coroutine.wrap(function()
						wait(0.45)
						if heck then
							heck:Destroy()
						end
					end)
					coru()
					knofe["big ass knife"].Touched:connect(function(hit)
						if hit.Parent ~= me and hit.Parent.Parent ~= me and hit.Transparency < 1 and knofe.Grab.CanCollide == false then
							heck.Velocity = Vector3.new(0,0,0)
							heck:Destroy()
							for i,v in pairs(knofe:GetChildren()) do
								if v:IsA('BasePart') then
									v.CanCollide = true
								end
							end
							local hum = hit.Parent:FindFirstChildOfClass('Humanoid')
							if hum == nil then
								hum = hit.Parent.Parent:FindFirstChildOfClass('Humanoid')
							end
							if knofe then
								local coru = coroutine.wrap(function()
									if hit then
										local uno = Instance.new('Part',workspace)
										local dos = Instance.new('Part',workspace)
										uno.CFrame = hit.CFrame
										dos.CFrame = knofe["big ass knife"].CFrame
										local weld = Instance.new('Weld',knofe["big ass knife"])
										weld.Part0 = hit
										weld.Part1 = knofe["big ass knife"]
										weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
										uno:Destroy()
										dos:Destroy()
									end
								end)
								coru()
							end
							local sound = Instance.new('Sound',knofe.Grab)
							sound.Name = "BOOM"
							sound.EmitterSize = 25
							sound.SoundId = 'rbxassetid://476477344'
							sound.Volume = 0.5
							sound:Play()
							local exppart = Instance.new("Part", game.Workspace)
							exppart.Size = Vector3.new(0.2, 0.2, 0.2)
							exppart.Anchored = true
							exppart.CanCollide = false
							exppart.CFrame = CFrame.new(knofe.Grab.CFrame.p)
							exppart.Transparency = 1
							local expaccent = Instance.new("ParticleEmitter", exppart)
							expaccent.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))})
							expaccent.LightEmission = 0.2
							expaccent.LightInfluence = 0.3
							expaccent.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 0)})
							expaccent.Acceleration = Vector3.new(0, 30, 0)
							expaccent.Drag = 15
							expaccent.LockedToPart = false
							expaccent.Lifetime = NumberRange.new(0.5, 1.5)
							expaccent.Rate = 2000
							expaccent.Speed = NumberRange.new(0,0)
							expaccent.SpreadAngle = Vector2.new(360, 360)
							expaccent:Clone().Parent = exppart
							expaccent:Clone().Parent = exppart
							local exp = Instance.new('Explosion',game.Workspace)
							exp.Position = knofe["big ass knife"].Position
							exp.ExplosionType = Enum.ExplosionType.NoCraters
							exp.BlastRadius = 5
							exp.Visible = false
							exp.BlastPressure = 0
							exp.DestroyJointRadiusPercent = 0
							exp.Hit:connect(function(hit)
								if hit.Parent and hit.Parent ~= me and hit.Parent.Name ~= "bitch ass knife" then
									wait(0.001)
									tgt = hit
									local coru=coroutine.wrap(function(tgtt)
										local fireofgods = Instance.new("Fire", tgtt)
										fireofgods.Size = 0
										fireofgods.Heat = 0
										local fireofgodsaccent = expaccent:Clone()
										fireofgodsaccent.Parent = hit
										fireofgodsaccent.Rate = 0
										fireofgodsaccent.Speed = NumberRange.new(5, 50)
										fireofgodsaccent.SpreadAngle = Vector2.new(45, 45)
										fireofgodsaccent.Acceleration = Vector3.new(0, 20, 0)

										while fireofgods.Size < 10 do
											fireofgods.Size = fireofgods.Size + 0.1
											fireofgods.Heat = fireofgods.Heat + 0.1
											fireofgodsaccent.Rate = fireofgodsaccent.Rate + 1
											wait()
										end
										if hit.Parent and hit.Parent:FindFirstChildOfClass('Humanoid') == nil and hit.Parent.Parent:FindFirstChildOfClass('Humanoid') == nil then
											hit:BreakJoints()
										elseif hit.Parent and hit.Parent:IsA('Accessory') then
											for i,v in pairs(hit:GetChildren()) do
												if v:IsA('SpecialMesh') then
													v.TextureId = ""
												end
											end
										end
										hit.BrickColor = BrickColor.new("Black")
										for i,v in pairs(hit.Parent:GetChildren()) do
											if v:IsA('Shirt') or v:IsA('Pants') then
												v:Destroy()
											end
										end

										while fireofgods.Size > 5 do
											fireofgods.Size = fireofgods.Size - 0.1
											fireofgods.Heat = fireofgods.Heat - 0.1
											wait()
										end
										fireofgods:Destroy()
										if hit.Parent then
											if hit.Parent:FindFirstChildOfClass('Humanoid') == nil and hit.Parent.Parent:FindFirstChildOfClass('Humanoid') == nil then
												local p = hit
												fragmentate(p.CFrame,p.Size,p.BrickColor,p.Position,0.01,p.BackSurface,p.BottomSurface,p.FrontSurface,p.LeftSurface,p.RightSurface,p.TopSurface,p.Transparency,p.Reflectance,p.Material)
												hit:Remove()
											elseif hit.Parent:FindFirstChildOfClass('Humanoid') ~= nil then
												print(hit.Name)
												if hit.Name == "Torso" or hit.Name == "Head" then
													print('ohhh YAAAA')
													hit.Parent:FindFirstChildOfClass('Humanoid').Health = 0
												end
												wait()
												killz(hit.Parent,hit.Name,nil,nil,false,false,true)
											end
										end
									end)
									coru(tgt)
								end
							end)
							local explosionaccenttimeout = coroutine.wrap(function()
								wait(0.2)
								for i, exploodn in pairs(exppart:GetChildren()) do
									exploodn.Enabled = false
								end
								wait(2)
								for i, exploodn in pairs(exppart:GetChildren()) do
									exploodn:Remove()
								end
							end)
							explosionaccenttimeout()
							for i,v in pairs(knofe:GetChildren()) do
								if v:IsA('BasePart') then
									v.Transparency = 1
								end
							end
							exp.AncestryChanged:connect(function() knofe:Destroy() end)
							coru()
						end
					end)
					if finishnum == 1 then
						for i= 0,1,0.1 do
							if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
							weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
							wait(0.001)
						end
					else
						wait(0.1)
					end
					weld2.C0 = CFrame.new(-1.5,0,0)
					for i,v in pairs(obj1:GetChildren()) do
						if v:IsA('BasePart') then
							v.Transparency = 0
						end
					end
					weld2:Destroy()
					rightshoulderz:Clone().Parent = me.Torso
				end
				acting = false
				canClick = true
			end)
			coru()
		end

		function fireworkit()
			local coru = coroutine.wrap(function()
				acting = true
				local ree = 1
				if finishnum > 1 then
					ree = 3
				end
				for i=1,ree do
					local weld2 = Instance.new('Weld',me["Right Arm"])
					weld2.Part0 = me["Right Arm"]
					weld2.Part1 = me["Torso"]
					weld2.C0 = CFrame.new(-1.5,0,0)
					weld2.C0 = CFrame.new(-1.5,0.9,-0.5)*CFrame.Angles(-math.pi/0.75,-math.pi/8,0)
					audio.SoundId = "rbxassetid://166083610"
					audio.PlaybackSpeed = 1
					audio.TimePosition = 0.1
					audio:Play()
					weld2.C0 = CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0)
					local knofe = obj1:Clone()
					for i,v in pairs(obj1:GetChildren()) do
						if v:IsA('BasePart') then
							v.Transparency = 1
						end
					end
					local sound = Instance.new('Sound',knofe.Grab)
					sound.Volume = 0.25
					sound.EmitterSize = 200
					sound.MaxDistance = 300
					sound.SoundId = 'rbxassetid://551051176'
					sound:Play()
					knofe.Parent = workspace
					knofe.Name = "Projectile"
					knofe.Grab.CFrame = CFrame.new(knofe.Grab.CFrame.p, mouse.Hit.p)*CFrame.Angles(0,math.pi/2,0)
					local partic = Instance.new('ParticleEmitter',knofe.Grab)
					partic.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,0,0)),ColorSequenceKeypoint.new(0.4,Color3.fromRGB(255,125,0)),ColorSequenceKeypoint.new(0.8,Color3.new(1,1,0)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))})
					partic.LightEmission = 0.5
					partic.LightInfluence = 0
					partic.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5),NumberSequenceKeypoint.new(1,0.15)})
					partic.Rotation = NumberRange.new(0,90)
					partic.SpreadAngle = Vector2.new(5,5)
					partic.Speed = NumberRange.new(20)
					partic.Texture = 'rbxassetid://603193846'
					partic.EmissionDirection = Enum.NormalId.Left
					partic.Lifetime = NumberRange.new(0.5,1)
					partic.Rate = 100
					local heck = Instance.new('BodyVelocity',knofe.Grab)
					heck.Velocity = (knofe.Grab.CFrame*CFrame.Angles(0,math.pi/-2,0)).lookVector*240
					knofe["big ass knife"].Touched:connect(function(hit)
						sound:Destroy()
						local sound2 = Instance.new('Sound',workspace)
						sound2.SoundId = 'rbxassetid://138080762'
						sound2:Play()
						if heck then
							heck:Destroy()
						end
						for i,v in pairs(knofe:GetChildren()) do
							v.Anchored = true
						end
						partic.Enabled = false
						local colorscheme = math.random(1,4)
						--1 - red & orange
						--2 - blue & pink
						--3 - green & purple
						--4 - blue, red, white
						local colar1 = Color3.fromRGB(255,0,0)
						local colar2 = Color3.fromRGB(255,125,0)
						local colar3 = Color3.fromRGB(255,255,255)
						if colorscheme == 2 then
							colar1 = Color3.fromRGB(0,132,255)
							colar2 = Color3.fromRGB(243,105,255)
						elseif colorscheme == 3 then
							colar1 = Color3.fromRGB(76,255,0)
							colar2 = Color3.fromRGB(128,0,255)
						elseif colorscheme == 4 then
							colar2 = Color3.fromRGB(0,132,255)
						end
						local partic2 = Instance.new('ParticleEmitter',knofe.Grab)
						partic2.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colar1),ColorSequenceKeypoint.new(1,colar1)})
						partic2.LightEmission = 0.5
						partic2.LightInfluence = 0
						partic2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5),NumberSequenceKeypoint.new(1,0.1)})
						partic2.Rotation = NumberRange.new(0,90)
						partic2.SpreadAngle = Vector2.new(180,180)
						partic2.Speed = NumberRange.new(20)
						partic2.Texture = 'rbxassetid://603193846'
						partic2.EmissionDirection = Enum.NormalId.Right
						partic2.Lifetime = NumberRange.new(2,2.5)
						partic2.Rate = 1000
						partic2.Drag = 1
						local partic3 = partic2:Clone()
						partic3.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colar2),ColorSequenceKeypoint.new(1,colar2)})
						partic3.Parent = knofe.Grab
						if colorscheme == 4 then
							local partic4 = partic2:Clone()
							partic4.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colar3),ColorSequenceKeypoint.new(1,colar3)})
							partic4.Parent = knofe.Grab
						end
						wait(1)
						for i,v in pairs(knofe.Grab:GetChildren()) do
							if v:IsA('ParticleEmitter') then
								v.Enabled = false
							end
						end
						sound:Destroy()
						wait(2)
						knofe:Destroy()
					end)
					wait(0.1)
					weld2.C0 = CFrame.new(-1.5,0,0)
					for i,v in pairs(obj1:GetChildren()) do
						if v:IsA('BasePart') then
							v.Transparency = 0
						end
					end
					weld2:Destroy()
					rightshoulderz:Clone().Parent = me.Torso
				end
				acting = false
				canClick = true
			end)
			coru()
		end

		function paralyze()
			local coru = coroutine.wrap(function()
				if paralyzed == true then return end
				paralyzed = true
				local arm = me["Right Arm"]
				local tors = grabbed.Torso
				local arm2 = me["Left Arm"]
				if arm:FindFirstChildOfClass('Weld') == nil or arm2:FindFirstChildOfClass('Weld') == nil then return end
				doing = true
				local weld2 = arm:FindFirstChildOfClass('Weld')
				local weld3 = arm2:FindFirstChildOfClass('Weld')
				local humanroot = me.HumanoidRootPart
				for i = 0,1,0.075 do
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 0.80, -1.1)* CFrame.Angles(-2, 0, -1.5), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 1, -0.5)* CFrame.Angles(-1.4, 0, 1.1), i)
					wait(0.01)
				end
				for i = 0,1,0.30 do
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 0.80, -1.1)* CFrame.Angles(-0.75, 0, -1.75), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 1, -0.5)* CFrame.Angles(-1.4, 0, 1.1), i)
					wait(0.01)
				end
				killz(grabbed,'Left Leg')
				killz(grabbed,'Left Arm')
				killz(grabbed,'Right Leg')
				killz(grabbed,'Right Arm')

				for i, v in pairs(grabbed:GetChildren()) do
					if v.Name == "Part" then
						v.CanCollide = false
					end
				end

				audio:Stop()
				audio.SoundId = "rbxassetid://2801263"
				tone = math.random(1, 3)
				if tone == 1 then audio.PlaybackSpeed = 0.8 audio.TimePosition = 0 end
				if tone == 2 then audio.PlaybackSpeed = 1 audio.TimePosition = 0 end
				if tone == 3 then audio.PlaybackSpeed = 1.2 audio.TimePosition = 0 end
				audio:Play()

				local bleedpart = Instance.new("Part", grabbed)
				bleedpart.Size = Vector3.new(0.2, 0.2, 0.2)
				bleedpart.Color = Color3.new(115/225, 115/225, 115/225)
				bleedpart.CanCollide = false
				bleedpart.Position = grabbed.Head.Position + Vector3.new(0, 1, 0)
				bleedpart.Transparency = 1

				local bleedpartweld = Instance.new("Weld", grabbed.Torso)
				bleedpartweld.Part0 = grabbed.Torso
				bleedpartweld.Part1 = bleedpart
				bleedpartweld.C0 = CFrame.Angles(-1, 0, -0.35) * CFrame.new(0, 1, 0.8)
				local cuntruu=coroutine.wrap(function()
					bleed(bleedpart)
				end)
				local thicc = coroutine.wrap(function()
					wait(3)
					bleedpart:Remove()
				end)
				cuntruu()
				thicc()

				for i = 0,1,0.075 do
					weld2.C0 = weld2.C0:lerp(CFrame.new(-0.9, 0.80, -1.1)* CFrame.Angles(-1.5, 0, -1.3), i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(0.8, 1, -0.5)* CFrame.Angles(-1.5, 0, 1.1), i)
					wait(0.01)
				end
				acting = true
				canClick = true
				doing = false
			end)
			coru()
		end

		function explode()
			local coru = coroutine.wrap(function()
				acting = true
				for i=1,finishnum do
					local weld2 = Instance.new('Weld',me["Right Arm"])
					weld2.Part0 = me["Right Arm"]
					weld2.Part1 = me["Torso"]
					weld2.C0 = CFrame.new(-1.5,0,0)
					if finishnum == 1 then
						for i = 0,1,0.05 do
							if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
							weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0.9,-0.5)*CFrame.Angles(-math.pi/0.75,-math.pi/8,0),i)
							wait(0.01)  
						end
					end
					weld2.C0 = CFrame.new(-1.5,0.9,-0.5)*CFrame.Angles(-math.pi/0.75,-math.pi/8,0)
					audio.SoundId = "rbxassetid://166083610"
					audio.PlaybackSpeed = 1
					audio.TimePosition = 0.1
					audio:Play()
					if finishnum == 1 then
						for i = 0,1,0.5 do
							if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
							weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0),i)
							wait(0.001) 
						end
					end
					weld2.C0 = CFrame.new(-1.5,1.2,0.1)*CFrame.Angles(math.pi/0.9,0,0)
					local knofe = obj1:Clone()
					for i,v in pairs(obj1:GetChildren()) do
						if v:IsA('BasePart') then
							v.Transparency = 1
						end
					end
					knofe.Parent = workspace
					knofe.Name = "Projectile"
					knofe.Grab.CFrame = CFrame.new(knofe.Grab.CFrame.p, mouse.Hit.p)*CFrame.Angles(0,math.pi/2,0)
					knofe:FindFirstChild("Trail", true).Enabled = false
					local heck = Instance.new('BodyVelocity',knofe.Grab)
					heck.Velocity = (knofe.Grab.CFrame*CFrame.Angles(0,math.pi/-2,0)).lookVector*120
					local coru = coroutine.wrap(function()
						wait(0.45)
						if heck then
							heck:Destroy()
						end
					end)
					coru()
					knofe["big ass knife"].Touched:connect(function(hit)
						if hit.Parent ~= me and hit.Parent.Parent ~= me and hit.Transparency < 1 and knofe.Grab.CanCollide == false then
							heck.Velocity = Vector3.new(0,0,0)
							heck:Destroy()
							for i,v in pairs(knofe:GetChildren()) do
								if v:IsA('BasePart') then
									v.CanCollide = true
								end
							end
							local hum = hit.Parent:FindFirstChildOfClass('Humanoid')
							if hum == nil then
								hum = hit.Parent.Parent:FindFirstChildOfClass('Humanoid')
							end
							if hum then
								tone = math.random(1, 3)
								local sound = Instance.new('Sound',knofe.Grab)
								if tone == 1 then sound.SoundId = "rbxassetid://220833967" end
								if tone == 2 then sound.SoundId = "rbxassetid://220833976" end
								if tone == 3 then sound.SoundId = "rbxassetid://220834000" end
								sound.PlaybackSpeed = 1
								sound:Play()
							else
								local sound = Instance.new('Sound',knofe.Grab)
								sound.SoundId = 'rbxassetid://267585646'
								sound:Play()
							end
							if knofe then
								local coru = coroutine.wrap(function()
									if hit then
										local uno = Instance.new('Part',workspace)
										local dos = Instance.new('Part',workspace)
										uno.CFrame = hit.CFrame
										dos.CFrame = knofe["big ass knife"].CFrame
										local weld = Instance.new('Weld',knofe["big ass knife"])
										weld.Part0 = hit
										weld.Part1 = knofe["big ass knife"]
										weld.C0 = uno.CFrame:toObjectSpace(dos.CFrame)
										uno:Destroy()
										dos:Destroy()
									end
								end)
								coru()
							end
							local coru = coroutine.wrap(function()
								for i=1,15,0.7 do
									local sound = Instance.new('Sound',knofe.Grab)
									if knofe then
										if knofe.serration.BrickColor == BrickColor.new('Really red') then
											for i, v in pairs(knofe:GetChildren()) do
												if v.Name == "big ass knife" or v.Name == "serration" or v.Name == "knifetip1" or v.Name == "fricc" then
													v.BrickColor = BrickColor.new('Lily white')
													v.Material = Enum.Material.SmoothPlastic
												end
											end
										else
											for i,v in pairs(knofe:GetChildren()) do
												if v.Name == "big ass knife" or v.Name == "serration" or v.Name == "knifetip1" or v.Name == "fricc" then
													v.BrickColor = BrickColor.new('Really red')
													v.Material = Enum.Material.Neon
													sound.SoundId = 'rbxassetid://300473653'
													sound.Volume = 0.75
													sound.TimePosition = 0.05
													sound.EmitterSize = 25
													sound.PlaybackSpeed = 1
													sound:Play()
												end
											end
										end
										wait(1/i)
										sound:Destroy()
									end
								end
								local sound = Instance.new('Sound',knofe.Grab)
								sound.Name = "BOOM"
								sound.EmitterSize = 25
								sound.SoundId = 'rbxassetid://12222084'
								sound.TimePosition = 0.1
								sound.Volume = 0.5
								sound:Play()
								local exppart = Instance.new("Part", game.Workspace)
								exppart.Size = Vector3.new(0.2, 0.2, 0.2)
								exppart.Anchored = true
								exppart.CanCollide = false
								exppart.CFrame = CFrame.new(knofe.Grab.CFrame.p)
								exppart.Transparency = 1
								local expaccent = Instance.new("ParticleEmitter", exppart)
								expaccent.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))})
								expaccent.LightEmission = 0.2
								expaccent.LightInfluence = 0.3
								expaccent.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 0)})
								expaccent.Acceleration = Vector3.new(0, -8, 0)
								expaccent.Drag = 15
								expaccent.LockedToPart = true
								expaccent.Lifetime = NumberRange.new(0.5, 1.5)
								expaccent.Rate = 2000
								expaccent.Speed = NumberRange.new(10, 150)
								expaccent.SpreadAngle = Vector2.new(360, 360)

								local exp = Instance.new('Explosion',game.Workspace)
								exp.Position = knofe["big ass knife"].Position
								exp.ExplosionType = Enum.ExplosionType.NoCraters
								exp.BlastRadius = 10
								exp.BlastPressure = 100000
								exp.DestroyJointRadiusPercent = 1
								exp.Hit:connect(function(hit)
									if hit.Parent and hit.Parent ~= me and hit.Parent:FindFirstChildOfClass('Humanoid') then
										if hit.Parent:FindFirstChildOfClass('Humanoid') and hit.Name == "Torso" or hit.Name == "Head" then
											hit.Parent:FindFirstChildOfClass('Humanoid').Health = 0
										end
										wait(0.001)
										local coru=coroutine.wrap(function()
											killz(hit.Parent,'Head',knofe,exp)
										end)
										coru()
									elseif hit.Parent and hit.Parent ~= workspace and hit.Parent ~= me then
										if hit.Parent.Name ~= "Projectile" then
											hit.Parent:BreakJoints()
										end
									elseif hit.Parent and hit.Parent ~= me then
										hit:BreakJoints()
									end
								end)
								local explosionaccenttimeout = coroutine.wrap(function()
									wait(0.2)
									expaccent.Enabled = false
									wait(2)
									exppart:Remove()
								end)
								explosionaccenttimeout()
								for i,v in pairs(knofe:GetChildren()) do
									if v:IsA('BasePart') then
										v.Transparency = 1
									end
								end
								exp.AncestryChanged:connect(function() knofe:Destroy() end)
							end)
							coru()
						end
					end)
					if finishnum == 1 then
						for i= 0,1,0.1 do
							if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil then return end
							weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
							wait(0.001)
						end
					else
						wait(0.1)
					end
					weld2.C0 = CFrame.new(-1.5,0,0)
					for i,v in pairs(obj1:GetChildren()) do
						if v:IsA('BasePart') then
							v.Transparency = 0
						end
					end
					weld2:Destroy()
					rightshoulderz:Clone().Parent = me.Torso
				end
				acting = false
				canClick = true
			end)
			coru()
		end

		function release()
			if grabbed.Torso:FindFirstChild("TargetWeld") == nil or grabbed:FindFirstChildOfClass('Humanoid').Health <= 0 then return end
			targetweld = grabbed.Torso.TargetWeld
			local ree= grabbed:FindFirstChild("Left Arm")
			targetweld2 = nil
			if ree and ree:FindFirstChild("Weld") then
				targetweld2 = ree.Weld
			end
			for i, v in pairs(grabbed:GetChildren()) do
				if v.Name == "Part" then
					v.CanCollide = true
				end
			end
			paralyzed = false
			local doit = coroutine.wrap(function()
				local arm = me["Right Arm"]
				local tors = grabbed.Torso
				local arm2 = me["Left Arm"]
				if arm:FindFirstChildOfClass('Weld') == nil or arm2:FindFirstChildOfClass('Weld') == nil then return end
				doing = true
				local weld2 = arm:FindFirstChildOfClass('Weld')
				local weld3 = arm2:FindFirstChildOfClass('Weld')
				local humanroot = me.HumanoidRootPart

				if grabbed:FindFirstChildOfClass('Humanoid') then
					grabbed:FindFirstChildOfClass('Humanoid').PlatformStand = false
				end

				rightshoulderz:Clone().Parent = me.Torso
				leftshoulderz:Clone().Parent = me.Torso
				grabbed = nil

				if humanroot:FindFirstChild('Holder') then
					humanroot.Holder:Destroy()
				end

				for i = 0,1,0.1 do
					if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld2 == nil or weld3 == nil then return end
					weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0),i)
					weld3.C0 = weld3.C0:lerp(CFrame.new(1.5,0,0),i)
					targetweld.C0 = targetweld.C0:lerp(CFrame.new(0, 1.5, 0)*CFrame.Angles(0, 0, 0), i)
					if targetweld2 then
						targetweld2.C0 = targetweld2.C0:lerp(CFrame.new(-1.5, 0, 0)*CFrame.Angles(0, 0, 0), i)
					end
					wait(0.01)
				end

				knifeweld.C1 = CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), 1.55) * CFrame.new(0, 0.95, 0.2)
				weld2:Destroy()
				weld3:Destroy()
				targetweld:Remove()
				if targetweld2 then
					targetweld2:Remove()
				end
				if rightshoulder then
					rightshoulder:Clone().Parent = tors
				end
				if leftshoulder then
					leftshoulder:Clone().Parent = tors
				end
				headweld:Clone().Parent = tors
				rightshoulderz:Clone().Parent = me.Torso
				leftshoulderz:Clone().Parent = me.Torso
				acting = false
				canClick = true
				doing = false
			end)
			doit()
		end

		function stabwithpassion()
			local doit = coroutine.wrap(function()
				if me:FindFirstChild('Right Arm') and me:FindFirstChild('Torso') and me:FindFirstChild('HumanoidRootPart') and me:FindFirstChild('Left Arm') then
					acting = true
					me:FindFirstChildOfClass('Humanoid').WalkSpeed = me:FindFirstChildOfClass('Humanoid').WalkSpeed + 10
					local arm = me["Right Arm"]
					local tors = me.Torso
					local arm2 = me["Left Arm"]
					local humanroot = me.HumanoidRootPart
					local weld = Instance.new('Weld',tors)
					weld.Part0 = tors
					weld.Part1 = humanroot
					weld.C0 = CFrame.new(0,0,0) * CFrame.Angles(0, 0, 0)
					local weld2 = Instance.new('Weld',arm)
					weld2.Part0 = arm
					weld2.Part1 = tors
					weld2.C0 = CFrame.new(-1.5,0,0) * CFrame.Angles(0, 0, 0)
					local weld3 = Instance.new('Weld',arm2)
					weld3.Part0 = arm2
					weld3.Part1 = tors
					weld3.C0 = CFrame.new(1.5,0,-0.3) * CFrame.Angles(0.3,0.1,0)

					for i = 0,1,0.15 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,math.rad(20),0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.2,1.3,0.4)*CFrame.Angles(0.5,0,-1.2),i)
						knifeweld.C1 = knifeweld.C1:lerp(CFrame.fromEulerAnglesXYZ(1.55, math.rad(90), -1.55) * CFrame.new(0, 0.95, 0), i)
						wait(0.01)
					end
					wait(0.001)
					trail.Enabled = true
					stabbing = true
					audio2.SoundId = 'rbxassetid://608537390'
					audio2:Play()
					for i = 0,1,0.2 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,math.rad(-45),0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.6,0.8,-1)*CFrame.Angles(math.rad(-90),0,-1),i)
						wait(0.01)
					end
					trail.Enabled = false
					wait(0.1)
					me:FindFirstChildOfClass('Humanoid').WalkSpeed = me:FindFirstChildOfClass('Humanoid').WalkSpeed - 10
					stabbing = false
					wait(0.001)
					for i = 0,1,0.075 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0,0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0)*CFrame.Angles(0,0,0),i)
						weld3.C0 = weld3.C0:lerp(CFrame.new(1.5,0,0)*CFrame.Angles(0,0,0),i)
						knifeweld.C1 = knifeweld.C1:lerp(CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), 1.55) * CFrame.new(0, 0.95, 0), i)
						wait(0.01)
					end
					weld:Destroy()
					weld2:Destroy()
					weld3:Destroy()
					torsojoint:Clone().Parent = humanroot
					rightshoulderz:Clone().Parent = me.Torso
					leftshoulderz:Clone().Parent = me.Torso
					canClick = true
					hit = false
					acting = false
				end
			end)
			doit()
		end

		function stab()
			local doit = coroutine.wrap(function()
				if me:FindFirstChild('Right Arm') and me:FindFirstChild('Torso') and me:FindFirstChild('HumanoidRootPart') and me:FindFirstChild('Left Arm') then
					acting = true
					me:FindFirstChildOfClass('Humanoid').WalkSpeed = me:FindFirstChildOfClass('Humanoid').WalkSpeed + 3
					local arm = me["Right Arm"]
					local tors = me.Torso
					local arm2 = me["Left Arm"]
					local humanroot = me.HumanoidRootPart
					local weld = Instance.new('Weld',tors)
					weld.Part0 = tors
					weld.Part1 = humanroot
					weld.C0 = CFrame.new(0,0,0) * CFrame.Angles(0, 0, 0)
					local weld2 = Instance.new('Weld',arm)
					weld2.Part0 = arm
					weld2.Part1 = tors
					weld2.C0 = CFrame.new(-1.5,0,0) * CFrame.Angles(0, 0, 0)
					local weld3 = Instance.new('Weld',arm2)
					weld3.Part0 = arm2
					weld3.Part1 = tors
					weld3.C0 = CFrame.new(1.5,0,-0.3) * CFrame.Angles(0.3,0.1,0)

					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0.3,0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.2,1.3,0.4)*CFrame.Angles(0.5,0,-1.2),i)
						wait(0.01)
					end
					wait(0.001)
					trail.Enabled = true
					stabbing = true
					audio2.SoundId = 'rbxassetid://608537390'
					audio2:Play()
					for i = 0,1,0.25 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,-0.3,0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.6,0.8,0.5)*CFrame.Angles(-0.5,0,-0.5),i)
						wait(0.01)
					end
					trail.Enabled = false
					wait(0.1)
					me:FindFirstChildOfClass('Humanoid').WalkSpeed = me:FindFirstChildOfClass('Humanoid').WalkSpeed - 3
					for i = 0,1,0.25 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0.3,0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0.6,-0.3)*CFrame.Angles(0.5,0,-0.5),i)
						wait(0.01)
					end
					stabbing = false
					wait(0.001)
					for i = 0,1,0.05 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil or weld2 == nil or humanroot == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0,0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(-1.5,0,0)*CFrame.Angles(0,0,0),i)
						weld3.C0 = weld3.C0:lerp(CFrame.new(1.5,0,0)*CFrame.Angles(0,0,0),i)
						wait(0.01)
					end
					weld:Destroy()
					weld2:Destroy()
					weld3:Destroy()
					torsojoint:Clone().Parent = humanroot
					rightshoulderz:Clone().Parent = me.Torso
					leftshoulderz:Clone().Parent = me.Torso
					canClick = true
					hit = false
					acting = false

					for i, plr in pairs(game.Players:GetChildren()) do
						if plr.Name ~= game.Players.LocalPlayer.Name then
							for i = 1, 10 do
								game.ReplicatedStorage.meleeEvent:FireServer(plr)
							end
						end
					end
				end
			end)
			doit()
		end
		function hardrelease()
			rightshoulderz:Clone().Parent = me.Torso
			leftshoulderz:Clone().Parent = me.Torso
			if me:FindFirstChild('Right Arm') then
				for i,v in pairs(me["Right Arm"]:GetChildren()) do
					if v:IsA('Weld') then
						v:Destroy()
					end
				end
			end
			if me:FindFirstChild('Left Arm') then
				for i,v in pairs(me["Left Arm"]:GetChildren()) do
					if v:IsA('Weld') then
						v:Destroy()
					end
				end
			end
			acting = false
			canClick = true
			doing = false
			grabbed = nil
		end
		function unequip()
			local doit = coroutine.wrap(function()
				if me:FindFirstChild('Right Arm') and me:FindFirstChild('Torso') then
					acting = true
					local arm = me["Right Arm"]
					local arm2 = me["Left Arm"]
					local tors = me.Torso
					local weld = Instance.new('Weld',arm)
					weld.Part0 = arm
					weld.Part1 = tors
					weld.C0 = CFrame.new(-1.5,0,0)
					local weld2 = Instance.new("Weld", arm2)
					weld2.Part0 = arm2
					weld2.Part1 = tors
					weld2.C0 = CFrame.new(1.5, 0, 0)
					wait(0.001)
					trail.Enabled = true
					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(-0.2,0.2,-0.5)*CFrame.Angles(0,-3.1,0.9),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(1.5, 0.6, 0) * CFrame.Angles(0,0,0.5),i)
						wait(0.001)
					end
					trail.Enabled = false
					wait(0.25)
					for i = 0,1,0.1 do
						if me:FindFirstChild('Right Arm') == nil or me:FindFirstChild('Torso') == nil or weld == nil then return end
						weld.C0 = weld.C0:lerp(CFrame.new(-1.5,0,0),i)
						weld2.C0 = weld2.C0:lerp(CFrame.new(1.5, 0, 0), i)
						wait(0.01)
					end
					weld:Destroy()
					weld2:Remove()
					if tors ~= nil then
						rightshoulderz:Clone().Parent = me.Torso
						leftshoulderz:Clone().Parent = me.Torso
					end
					acting = false
				end
			end)
			doit()
		end

		mouse.KeyDown:connect(function(key)
			if usable == true then
				if key == "z" then
					if active == false and acting == false then
						active = true
						if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
						notify("KNIFE EQUIPPED",false)
						audio:Stop()
						audio.SoundId = 'rbxassetid://608618332'
						equip()
						wait(0.6)
						audio:Play()
						knifeweld.Part0 = me["Right Arm"]
						knifeweld.C1 = CFrame.fromEulerAnglesXYZ(1.55, math.rad(-90), 1.55) * CFrame.new(0, 0.95, 0)
					elseif acting == false then
						active = false
						if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
						audio:Stop()
						audio.SoundId = 'rbxassetid://608538233'
						unequip()
						notify("KNIFE UNEQUIPPED",false)
						wait(0.3)
						audio:Play()
						knifeweld.Part0 = me.Torso
						knifeweld.C1 = CFrame.Angles(0,math.rad(90),0) * CFrame.new(1, 0.8, 0.55)
						canClick = true
					end
				elseif key == "f" then
					if mode == 'kill' or active == false then return end
					mode = "kill"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || KILL || [F]",false)
				elseif key == "e" then
					if mode == 'throw' or active == false then return end
					mode = "throw"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || PUSH || [E]",false)
				elseif key == "q" then
					if mode == 'release' or active == false then return end
					mode = "release"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || RELEASE || [Q]",false)
				elseif key == "x" then
					if mode == 'stab' or active == false or acting == true then return end
					mode = "stab"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || STAB || [X]",false)
				elseif key == "c" then
					if mode == 'fling' or active == false or acting == true then return end
					mode = "fling"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || THROW || [C]",false)
				elseif key == "b" then
					if mode == 'instasplode' or active == false or acting == true then return end
					mode = "instasplode"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || MOLOTOV || [B]",false)
				elseif key == "r" then
					if mode == 'paralyze' or active == false then return end
					mode = "paralyze"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || PARALYZE || [R]",false)
				elseif key == "v" then
					if mode == 'explode' or active == false or acting == true then return end
					mode = "explode"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || EXPLODE || [V]",false)
				elseif key == "k" then
					if mode == 'suicide' or active == false or acting == true then return end
					mode = "suicide"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || SUICIDE || [K]",false)
				elseif key == "h" then
					if mode == 'firework' or active == false or acting == true then return end
					mode = "firework"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					notify("MODE || FIREWORK || [H]",false)
				elseif key == "g" then
					if mode == 'finish' or active == false then return end
					mode = "finish"
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					local welp = "ON"
					if finishnum == 1 then
						welp = "OFF"
					end
					notify("MODE || FINISH || [G] || "..welp,false)
				elseif key == "n" then
					if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
					if zombiemode == false then
						notify("ZOMBIE MODE ON || [N]",false)
						zombiemode = true
					else
						notify("ZOMBIE MODE OFF || [N]",false)
						zombiemode = false
					end
				elseif key == "m" then
					if finishnum == 1 then
						finishnum = 15
						if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
						notify("PSYCHOPATH MODE ON || [M]",false)
						if cancolorfilter then
							local Sp00kyGui = Instance.new("ScreenGui")
							local ImageLabel = Instance.new("ImageLabel")

							-- Properties

							Sp00kyGui.Parent = playergui
							Sp00kyGui.Name = "REEEEEEEE"

							ImageLabel.Parent = Sp00kyGui
							ImageLabel.BackgroundColor3 = Color3.new(1, 1, 1)
							ImageLabel.BackgroundTransparency = 1
							ImageLabel.Size = UDim2.new(1, 0, 1, 0)
							ImageLabel.Image = "rbxassetid://74443700"
							ImageLabel.ImageColor3 = Color3.new(1, 0, 0)
						end
						if canbackgroundmusic == true then
							local sound = Instance.new('Sound',playergui)
							sound.Name = 'PSYCHOPAAAATH'
							sound.SoundId = 'rbxassetid://220875210'
							sound.Looped = true
							sound.Volume = 0.5
							sound:Play()
						end
					else
						finishnum = 1
						if playergui:FindFirstChild('Notification') then playergui.Notification:Destroy() end
						notify("PSYCHOPATH MODE OFF || [M]",false)
						for i,v in pairs(playergui:GetChildren()) do
							if v.Name == "REEEEEEEE" then
								v:Destroy()
							end
						end
						local thisniggarighthere = playergui:FindFirstChild('PSYCHOPAAAATH')
						if thisniggarighthere then thisniggarighthere:Destroy() end
					end
				end
			end
		end)

		mouse.Button1Down:connect(function()
			if active == false or usable == false then return end
			if canClick == true and acting == false then
				if mode == "stab" and finishnum == 1 then
					canClick = false
					stab()
				elseif mode == "stab" and finishnum == 15 then
					canClick = false
					stabwithpassion()
				elseif mode == "fling" then
					canClick = false
					fling()
				elseif mode == "explode" then
					canClick = false
					explode()
				elseif mode == "instasplode" then
					canClick = false
					instasplode()
				elseif mode == "finish" then
					canClick = false
					finish()
				elseif mode == "suicide" then
					canClick = false
					kysnigga()
				elseif mode == "firework" then
					canClick = false
					fireworkit()
				else
					canClick = false
					grab()
				end
			else
				if grabbed ~= nil and doing == false then
					if mode == "release" then
						if acting == true and grabbed:FindFirstChildOfClass('Humanoid') and grabbed:FindFirstChildOfClass('Humanoid').Health > 0 then
							release()
						else
							hardrelease()
						end
					elseif mode == "kill" then
						if acting == true and grabbed:FindFirstChildOfClass('Humanoid') and grabbed:FindFirstChildOfClass('Humanoid').Health > 0 then
							kill()
						else
							hardrelease()
						end
					elseif mode == "paralyze" then
						if acting == true and grabbed:FindFirstChildOfClass('Humanoid') and grabbed:FindFirstChildOfClass('Humanoid').Health > 0 then
							paralyze()
						else
							hardrelease()
						end
					elseif mode == "throw" then
						if acting == true and grabbed:FindFirstChildOfClass('Humanoid') and grabbed:FindFirstChildOfClass('Humanoid').Health > 0 then
							throw()
						else
							hardrelease()
						end
					elseif mode == "explode" then
						if acting == true and grabbed:FindFirstChildOfClass('Humanoid') and grabbed:FindFirstChildOfClass('Humanoid').Health > 0 then
							throw()
						else
							hardrelease()
						end
					end
				end
			end
		end)

		knife.Touched:connect(function(hitz)
			if hitz.Parent and hitz.Parent:FindFirstChildOfClass("Humanoid") and hitz.Parent:FindFirstChild('Torso') and acting == true then
				if mode == "stab" and stabbing == true and hit == false then
					hit = true
					tone = math.random(1, 3)
					audio:Stop()
					if tone == 1 then audio.SoundId = "rbxassetid://220833967" end
					if tone == 2 then audio.SoundId = "rbxassetid://220833976" end
					if tone == 3 then audio.SoundId = "rbxassetid://220834000" end
					audio.PlaybackSpeed = 1
					audio:Play()
					killz(hitz.Parent,'Left Leg')
					killz(hitz.Parent,'Left Arm')
					killz(hitz.Parent,'Right Leg')
					killz(hitz.Parent,'Right Arm')
				elseif mode == "finish" and finishing == true then
					print('PSYCHOPATH MODE REEEEEEEEEEEEEEEE')
					tone = math.random(1, 3)
					audio:Stop()
					if tone == 1 then audio.SoundId = "rbxassetid://220833967" end
					if tone == 2 then audio.SoundId = "rbxassetid://220833976" end
					if tone == 3 then audio.SoundId = "rbxassetid://220834000" end
					audio.PlaybackSpeed = 1
					audio:Play()
					if hit == false then
						hitz.Parent:FindFirstChildOfClass('Humanoid').Health = 0
						wait()
						killz(hitz.Parent,'Head',nil,false,true)
					end
					hit = true
				elseif grabbed == nil and grabbing == true and hit == false then
					if hitz.Parent:FindFirstChildOfClass("Humanoid").Health > 0 and hitz.Parent:FindFirstChild('Torso') and hitz.Parent.Torso:FindFirstChild('Neck') then
						grabbed = hitz.Parent
						local weldz = Instance.new('Weld',point)
						weldz.Name = "Holder"
						weldz.Part0 = point
						weldz.Part1 = hitz.Parent.Torso
						weldz.C0 = CFrame.new(0,0,-1.2)
					end
				end
			end
		end)

		player.CharacterAdded:connect(function()
			usable = false
			for i,v in pairs(playergui:GetChildren()) do
				if v.Name == "REEEEEEEE" or v.Name == 'PSYCHOPAAAATH' then
					v:Destroy()
				end
			end
		end)
		while usable do
			local coru = coroutine.wrap(function()
				if grabbed ~= nil then
					if grabbed:FindFirstChildOfClass('Humanoid') and grabbed:FindFirstChildOfClass('Humanoid').Health > 0 then
						for i,v in pairs(grabbed:GetChildren()) do
							if v:IsA('Tool') then
								local model = Instance.new('Model',workspace)
								v.Parent = model
								model:TranslateBy(Vector3.new(3,0,0))
							end
						end
						grabbed:FindFirstChildOfClass('Humanoid').Name = "Hoomanoid"
						grabbed:FindFirstChildOfClass('Humanoid').JumpPower = 0
						grabbed:FindFirstChildOfClass('Humanoid').WalkSpeed = 0
						grabbed:FindFirstChildOfClass('Humanoid').PlatformStand = true
						grabweld = grabbed.Torso:FindFirstChild("TargetWeld")
						if grabweld ~= nil then return end
						grabbed:FindFirstChildOfClass('Humanoid').PlatformStand = true
						if grabbed.Torso:FindFirstChild('Left Shoulder') then
							leftshoulder = grabbed.Torso["Left Shoulder"]:Clone()
						end
						if grabbed.Torso:FindFirstChild('Right Shoulder') then
							rightshoulder = grabbed.Torso["Right Shoulder"]:Clone()
						end
						headweld = grabbed.Torso["Neck"]:Clone()
						local targetweld = Instance.new('Weld',grabbed.Torso)
						targetweld.Part0 = grabbed.Torso
						targetweld.Part1 = grabbed.Head
						targetweld.Name = "TargetWeld"
						targetweld.C0 = CFrame.new(0,1.5,0) * CFrame.Angles(0, 0, 0)
						if grabbed:FindFirstChild('Left Arm') then
							local targetweld2 = Instance.new('Weld',grabbed["Left Arm"])
							targetweld2.Part0 = grabbed.Torso
							targetweld2.Part1 = grabbed["Left Arm"]
							targetweld2.C0 = CFrame.new(-1.5,0,0) * CFrame.Angles(0, 0, 0)
						end

						for i = 0,1,0.1 do
							if me:FindFirstChild("Left Arm") == nil or me:FindFirstChild("Torso") == nil or targetweld == nil then return end
							targetweld.C0 = targetweld.C0:lerp(CFrame.new(0, 1.5, 0)*CFrame.Angles(0.25, 0, 0), i)
							if targetweld2 then
								targetweld2.C0 = targetweld2.C0:lerp(CFrame.new(-1.5, 0.5, 0)*CFrame.Angles(0, 0, -0.55), i)
							end
							wait(0.001)
						end
					end
				end
			end)
			coru()
			wait()
		end

	end
	local coru=coroutine.wrap(function()
		nub()
	end)
	coru()

	player.CharacterAppearanceLoaded:connect(function()
		local coru =coroutine.wrap(function()
			nub()
		end)
		coru()
	end)

	while true do
		local coru=coroutine.wrap(function()
			for i,v in pairs(rekt) do
				if v and v:FindFirstChildOfClass('Humanoid') then
					for a,c in pairs(v:GetChildren()) do
						if c:IsA('Tool') then
							local model = Instance.new('Model',workspace)
							c.Parent = model
							model:TranslateBy(Vector3.new(3,0,0))
						end
					end
					v:FindFirstChildOfClass('Humanoid').Jump = false
					v:FindFirstChildOfClass('Humanoid').Sit = false
					v:FindFirstChildOfClass('Humanoid').JumpPower = 0
					v:FindFirstChildOfClass('Humanoid').PlatformStand = true
					v:FindFirstChildOfClass('Humanoid').Name = "No escape."
					local thing = getplr(v)
					if thing then
						thing.CameraMinZoomDistance = 3
					end
				else
					local thing = getplr(v)
					if thing then
						thing.CameraMinZoomDistance = 0.5
					end
					table.remove(rekt,i)
				end
			end
		end)
		coru()
		local coru2 = coroutine.wrap(function()
			if curpart then
				curpoint = curpart.CFrame.p
			end
			if lastgui then
				lastgui:Destroy()
				lastgui = nil
			end
			if curpoint then
				lastgui = Instance.new('BillboardGui',player.PlayerGui)
				lastgui.AlwaysOnTop = true
				lastgui.MaxDistance = 0
				lastgui.Size = UDim2.new(5,0,5,0)
				if curpart == nil then
					lastgui.Adornee = workspace
					lastgui.StudsOffsetWorldSpace = curpoint
				else
					lastgui.Adornee = curpart
				end
				local cross = Instance.new('ImageLabel',lastgui)
				cross.BackgroundTransparency = 1
				cross.Size = UDim2.new(1,0,1,0)
				cross.Image = 'rbxassetid://316279304'
				for i,v in pairs(zombies) do
					if v:FindFirstChildOfClass('Humanoid') then
						v:FindFirstChildOfClass('Humanoid').WalkToPoint = curpoint
					end
				end
			else
				for i,v in pairs(zombies) do
					if v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Head') then
						v:FindFirstChildOfClass('Humanoid').WalkToPoint = v.Head.Position
					end
				end
			end
		end)
		coru2()
		wait()
	end
end)


UICorner_11.Parent = Execute10

Execute11.Name = "Execute11"
Execute11.Parent = Main
Execute11.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute11.BorderSizePixel = 0
Execute11.Position = UDim2.new(0.54900682, 0, 0.325672269, 0)
Execute11.Size = UDim2.new(0, 238, 0, 50)
Execute11.Font = Enum.Font.SourceSans
Execute11.Text = "Server Admin God (FE Unknown)"
Execute11.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute11.TextSize = 21.000
Execute11.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
end)

UICorner_12.Parent = Execute11

Execute12.Name = "Execute12"
Execute12.Parent = Main
Execute12.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Execute12.BorderSizePixel = 0
Execute12.Position = UDim2.new(0.54900682, 0, 0.149390221, 0)
Execute12.Size = UDim2.new(0, 238, 0, 50)
Execute12.Font = Enum.Font.SourceSans
Execute12.Text = "Deathsploit 1.0 (Old)"
Execute12.TextColor3 = Color3.fromRGB(0, 0, 0)
Execute12.TextSize = 21.000
Execute12.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://deathploit.xyz/deathsploit1.0.lua"))()
end)

UICorner_13.Parent = Execute12
